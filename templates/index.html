<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSFlow - Tailnet Flow Visualizer</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233b82f6'%3E%3Cpath d='M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z'/%3E%3Ccircle cx='8' cy='10' r='1.5' fill='white'/%3E%3Ccircle cx='16' cy='10' r='1.5' fill='white'/%3E%3Ccircle cx='12' cy='14' r='1.5' fill='white'/%3E%3Cline x1='8' y1='10' x2='12' y2='14' stroke='white' stroke-width='1'/%3E%3Cline x1='16' y1='10' x2='12' y2='14' stroke='white' stroke-width='1'/%3E%3C/svg%3E">
    <link rel="shortcut icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233b82f6'%3E%3Cpath d='M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z'/%3E%3Ccircle cx='8' cy='10' r='1.5' fill='white'/%3E%3Ccircle cx='16' cy='10' r='1.5' fill='white'/%3E%3Ccircle cx='12' cy='14' r='1.5' fill='white'/%3E%3Cline x1='8' y1='10' x2='12' y2='14' stroke='white' stroke-width='1'/%3E%3Cline x1='16' y1='10' x2='12' y2='14' stroke='white' stroke-width='1'/%3E%3C/svg%3E">
    
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Tailscale Authentic Dark Theme */
        body { background: #0f172a; color: #f8fafc; }
        .tailscale-header { background: #1e293b; border-bottom: 1px solid #334155; }
        .tailscale-primary { background: #3b82f6; }
        .tailscale-secondary { background: #6366f1; }
        .node { cursor: pointer; }
        .external-node { cursor: pointer; }
        .external-node:hover { transform: scale(1.05); }
        .flow-line { opacity: 0.9; }
        .flow-line.tcp { stroke: #3b82f6; }
        .flow-line.udp { stroke: #10b981; }
        .flow-line.icmp { stroke: #f59e0b; }
        .flow-line.raw { stroke: #8b5cf6; }
        .flow-line.proto-0 { stroke: #6b7280; }
        .flow-line.mixed { stroke: #8b5cf6; }
        .flow-line:hover { opacity: 1; }
        .flow-line.subnet { stroke-dasharray: 5,5; }
        .flow-line.physical { stroke-dasharray: none; }
        .flow-line.virtual { stroke-dasharray: 2,2; }
        .sidebar { 
            background: #1e293b; 
            border-right: 1px solid #334155; 
            transition: all 0.3s ease;
            overflow: hidden;
            min-width: 0;
        }
        .sidebar.collapsed { 
            width: 0 !important; 
            min-width: 0 !important;
            transform: translateX(-100%);
        }
        .main-content {
            transition: all 0.3s ease;
            flex: 1;
            min-width: 0;
        }
        .error-message { background: #7f1d1d; border: 1px solid #dc2626; color: #fca5a5; }
        .warning-message { background: #92400e; border: 1px solid #f59e0b; color: #fde68a; }
        .search-bar { background: #1e293b; border-bottom: 1px solid #334155; }
        .tag-badge { 
            background: #1e40af; 
            color: #dbeafe; 
            border: 1px solid #3b82f6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60px;
            display: inline-block;
            font-size: 10px;
            line-height: 1.2;
        }
        .machine-card { 
            background: #334155; 
            border: 1px solid #475569; 
            transition: all 0.2s;
            color: #f8fafc;
        }
        .machine-card:hover { border-color: #3b82f6; background: #475569; }
        .machine-card.online { border-color: #10b981; }
        .machine-card.selected { border-color: #3b82f6; background: #1e3a8a; }
        .external-ip-card { 
            background: #7c2d12; 
            border: 1px solid #ea580c; 
            color: #fed7aa;
            cursor: pointer;
            transition: all 0.2s;
        }
        .external-ip-card:hover { background: #9a3412; border-color: #f97316; }
        .connected-dot { width: 8px; height: 8px; background: #10b981; border-radius: 50%; flex-shrink: 0; }
        .disconnected-dot { width: 8px; height: 8px; background: #64748b; border-radius: 50%; flex-shrink: 0; }
        input, select { background: #334155; border: 1px solid #475569; color: #f8fafc; }
        input:focus, select:focus { border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; outline: none; }
        button { transition: all 0.2s; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .section-header { color: #94a3b8; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        
        /* Flow Log Viewer Styles */
        #flowLogViewer {
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        #flowLogViewer thead {
            background-color: #374151 !important;
        }
        
        #flowLogViewer thead th {
            background-color: #374151 !important;
        }
        
        #flowLogBody tr:hover {
            background-color: #374151;
        }
        
        #flowLogBody tr.bg-blue-900 {
            background-color: #1e3a8a !important;
        }
        
        #flowLogBody tr.bg-blue-900:hover {
            background-color: #1d4ed8 !important;
        }
        
        .max-w-32 {
            max-width: 8rem;
        }

        /* Responsive design */
        @media (max-width: 1024px) {
            .sidebar { width: 280px; }
        }
        @media (max-width: 768px) {
            .sidebar { width: 260px; }
            .search-bar { padding: 1rem; }
            #flowLogViewer { height: 250px !important; }
            #flowLogViewer.collapsed { height: 49px !important; }
        }
        @media (max-width: 640px) {
            .sidebar.collapsed { transform: translateX(-100%); }
            #flowLogViewer { height: 200px !important; }
        }
    </style>
</head>
  <body>
    <div class="flex h-screen">
        <!-- Sidebar -->
        <div id="sidebar" class="w-80 sidebar overflow-y-auto">
            <div class="p-4">
                <!-- Sidebar Header -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center space-x-2">
                        <svg class="w-6 h-6 text-blue-400" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2L2 7v10c0 5.55 3.84 9.74 9 11 5.16-1.26 9-5.45 9-11V7l-10-5z"/>
                        </svg>
                        <h2 class="text-lg font-semibold text-slate-200">TSFlow</h2>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="refreshBtn" class="p-2 hover:bg-slate-600 rounded transition-all" title="Refresh Data">
                            <i class="fas fa-sync-alt text-slate-300"></i>
                        </button>
                        <button id="collapseSidebar" class="p-2 hover:bg-slate-600 rounded transition-all">
                            <i class="fas fa-chevron-left text-slate-300"></i>
                        </button>
                    </div>
                </div>
                <!-- Time Range Selector -->
                <div class="mb-4">
                    <h3 class="section-header mb-2">Time Range</h3>
                    <div class="space-y-2">
                        <div class="grid grid-cols-2 gap-1">
                            <button class="time-preset bg-slate-600 hover:bg-slate-500 text-slate-100 px-2 py-1 rounded text-xs transition-all border border-slate-500" data-range="15min">15min</button>
                            <button class="time-preset bg-slate-600 hover:bg-slate-500 text-slate-100 px-2 py-1 rounded text-xs transition-all border border-slate-500" data-range="1h">1h</button>
                            <button class="time-preset bg-slate-600 hover:bg-slate-500 text-slate-100 px-2 py-1 rounded text-xs transition-all border border-slate-500" data-range="3h">3h</button>
                            <button class="time-preset bg-slate-600 hover:bg-slate-500 text-slate-100 px-2 py-1 rounded text-xs transition-all border border-slate-500" data-range="6h">6h</button>
                        </div>
                        <div class="space-y-1">
                            <input type="datetime-local" id="startTime" class="w-full px-2 py-1 text-xs rounded">
                            <input type="datetime-local" id="endTime" class="w-full px-2 py-1 text-xs rounded">
                        </div>
                        <button id="applyTimeRange" class="w-full btn-primary px-3 py-1 rounded text-xs">
                            Apply
                        </button>
                    </div>
                </div>



                <!-- View Mode -->
                <div class="mb-4">
                    <h3 class="section-header mb-2">Layout</h3>
                    <div class="space-y-1">
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="viewMode" value="topology" checked class="text-blue-500">
                            <span class="text-xs text-slate-300">Force</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="viewMode" value="circular" class="text-blue-500">
                            <span class="text-xs text-slate-300">Circular</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="viewMode" value="grid" class="text-blue-500">
                            <span class="text-xs text-slate-300">Grid</span>
                        </label>
                    </div>
                </div>



                <!-- Machines List -->
                <div class="mb-4">
                    <h3 class="section-header mb-2">Machines</h3>
                    <div id="devicesList" class="space-y-1 max-h-80 overflow-y-auto">
                        <!-- Machines will be populated here -->
                    </div>
                </div>

                <!-- Selected Machine Details -->
                <div id="deviceDetails" class="hidden">
                    <h3 class="section-header mb-2">Details</h3>
                    <div id="deviceInfo" class="space-y-1">
                        <!-- Machine details will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content flex flex-col">
            <!-- Dynamic Search Bar -->
            <div class="search-bar px-6 py-4">
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center space-x-4">
                        <button id="expandSidebar" class="p-2 rounded hover:bg-slate-600 transition-all hidden text-slate-300" title="Show Control Panel">
                            <i class="fas fa-bars"></i>
                        </button>
                        <h2 class="text-xl font-semibold text-slate-200">Tailnet Flow Map</h2>
                        <div class="flex items-center space-x-2 text-sm text-slate-400">
                            <span id="deviceCount">0 machines</span>
                            <span>â€¢</span>
                            <span id="flowCount">0 flows</span>
                            <span>â€¢</span>
                            <span id="tailnetThroughput" class="text-blue-400 font-medium">0 B/s</span>
                            <span>â€¢</span>
                            <span id="loadTime" class="text-xs">--</span>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="pauseSimulation" class="p-2 rounded hover:bg-slate-600 transition-all text-slate-300" title="Pause/Resume Animation">
                            <i class="fas fa-pause"></i>
                        </button>
                        <button id="zoomIn" class="p-2 rounded hover:bg-slate-600 transition-all text-slate-300">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button id="zoomOut" class="p-2 rounded hover:bg-slate-600 transition-all text-slate-300">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <button id="resetZoom" class="p-2 rounded hover:bg-slate-600 transition-all text-slate-300">
                            <i class="fas fa-compress-arrows-alt"></i>
                        </button>
                        <button id="exportData" class="btn-primary px-4 py-2 rounded">
                            <i class="fas fa-download mr-2"></i>Export Data
                        </button>
                    </div>
                </div>
                
                <!-- Dynamic Search/Filter Bar -->
                <div class="flex items-center space-x-4">
                    <div class="flex-1 relative">
                        <input type="text" id="dynamicSearch" placeholder="Search machines, IPs, protocols, tags... (e.g., 'protocol:tcp', 'tag:exit-node', 'traffic:>10mb')" 
                               class="w-full px-4 py-2 pl-10 rounded-lg">
                        <i class="fas fa-search absolute left-3 top-3 text-slate-400"></i>
                    </div>
                    <div class="flex items-center space-x-2">
                        <select id="quickFilterProtocol" class="px-3 py-2 rounded text-sm">
                            <option value="">All Protocols</option>
                            <option value="TCP">TCP</option>
                            <option value="UDP">UDP</option>
                            <option value="ICMP">ICMP</option>
                            <option value="RAW">RAW</option>
                            <option value="proto-0">Proto-0</option>
                        </select>
                        <select id="quickFilterTraffic" class="px-3 py-2 rounded text-sm">
                            <option value="0">All Traffic</option>
                            <option value="1">1+ MB</option>
                            <option value="10">10+ MB</option>
                            <option value="100">100+ MB</option>
                            <option value="1000">1+ GB</option>
                        </select>
                        <input type="text" id="portFilter" placeholder="Ports (e.g., 22,80,443)" 
                               class="px-3 py-2 rounded text-sm w-32">
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showExternalIPs" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">External IPs</span>
                        </label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showVirtualTraffic" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">Virtual</span>
                        </label>
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showPhysicalTraffic" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">Physical</span>
                        </label>
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showSubnetTraffic" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">Subnet</span>
                        </label>
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showIPv4Traffic" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">IPv4</span>
                        </label>
                        <label class="flex items-center space-x-2 px-3 py-2 border border-slate-600 rounded hover:bg-slate-600 cursor-pointer">
                            <input type="checkbox" id="showIPv6Traffic" class="text-blue-500" checked>
                            <span class="text-sm text-slate-300">IPv6</span>
                        </label>
                        <button id="clearAllFilters" class="px-3 py-2 text-sm text-slate-300 hover:text-slate-100 border border-slate-600 rounded hover:bg-slate-600">
                            Clear
                        </button>
                    </div>
                </div>
                

            </div>

            <!-- Error/Warning Messages -->
            <div id="messageArea" class="hidden px-6 py-3">
                <!-- Messages will be displayed here -->
            </div>

            <!-- Visualization Area -->
            <div class="flex-1 relative overflow-hidden">
                <div id="loading" class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 z-10">
                    <div class="text-center">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                        <p class="text-gray-600" id="loadingMessage">Loading Tailnet data...</p>
                        <div class="mt-2">
                            <button id="cancelLoad" class="text-sm text-red-600 hover:text-red-700 underline">Cancel</button>
                        </div>
                    </div>
                </div>
                <svg id="networkMap" class="w-full h-full"></svg>
            </div>

            <!-- Flow Log Viewer (Hubble UI style) -->
            <div id="flowLogViewer" class="bg-slate-800 border-t border-slate-600 transition-all duration-300" style="height: 300px;">
                <div class="bg-slate-700 border-b border-slate-600">
                    <div class="flex items-center justify-between p-3">
                        <div class="flex items-center space-x-3">
                            <h3 class="text-sm font-semibold text-slate-200 flex items-center">
                                <i class="fas fa-stream mr-2 text-blue-400"></i>
                                Flow Logs
                                <span id="flowLogFocusIndicator" class="ml-2 text-xs bg-orange-600 text-orange-100 px-2 py-1 rounded hidden"></span>
                            </h3>
                            <div class="flex items-center space-x-2 text-xs text-slate-400">
                                <span id="flowLogCount">0 flows</span>
                                <span>â€¢</span>
                                <span id="flowLogRate">0/s</span>
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button id="clearFlowSelection" class="p-1.5 rounded hover:bg-slate-600 transition-all text-slate-300 hidden" title="Clear Selection">
                                <i class="fas fa-times text-xs"></i>
                            </button>
                            <button id="exportFlowLogs" class="p-1.5 rounded hover:bg-slate-600 transition-all text-slate-300" title="Export Logs">
                                <i class="fas fa-download text-xs"></i>
                            </button>
                            <button id="toggleFlowViewer" class="p-1.5 rounded hover:bg-slate-600 transition-all text-slate-300" title="Collapse/Expand">
                                <i class="fas fa-chevron-down text-xs"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Flow Log Filters -->
                    <div class="px-3 pb-3 flex items-center space-x-3">
                        <input type="text" id="flowLogSearch" placeholder="Search flows..." 
                               class="px-2 py-1 text-xs rounded w-40 bg-slate-600 border border-slate-500 text-slate-200">
                        <select id="flowLogProtocol" class="px-2 py-1 text-xs rounded bg-slate-600 border border-slate-500 text-slate-200">
                            <option value="">All Protocols</option>
                            <option value="TCP">TCP</option>
                            <option value="UDP">UDP</option>
                            <option value="ICMP">ICMP</option>
                            <option value="RAW">RAW</option>
                            <option value="proto-0">Proto-0</option>
                        </select>
                        <input type="text" id="flowLogPort" placeholder="Port" 
                               class="px-2 py-1 text-xs rounded w-16 bg-slate-600 border border-slate-500 text-slate-200">
                        <input type="number" id="flowLogMinBytes" placeholder="Min bytes" 
                               class="px-2 py-1 text-xs rounded w-20 bg-slate-600 border border-slate-500 text-slate-200">
                        <label class="flex items-center space-x-1 text-xs text-slate-300">
                            <input type="checkbox" id="flowLogShowExternal" checked class="text-blue-500">
                            <span>External</span>
                        </label>
                        <label class="flex items-center space-x-1 text-xs text-slate-300">
                            <input type="checkbox" id="flowLogShowIPv4" checked class="text-blue-500">
                            <span>IPv4</span>
                        </label>
                        <label class="flex items-center space-x-1 text-xs text-slate-300">
                            <input type="checkbox" id="flowLogShowIPv6" checked class="text-blue-500">
                            <span>IPv6</span>
                        </label>
                        <button id="clearFlowLogFilters" class="px-2 py-1 text-xs text-slate-300 hover:text-slate-100 border border-slate-500 rounded hover:bg-slate-600">
                            Clear
                        </button>
                    </div>
                    <!-- Flow Log Pagination -->
                    <div class="px-3 pb-2 flex items-center justify-between text-xs">
                        <div class="flex items-center space-x-2">
                            <button id="flowLogFirstPage" class="px-2 py-1 bg-slate-600 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fas fa-angle-double-left"></i>
                            </button>
                            <button id="flowLogPrevPage" class="px-2 py-1 bg-slate-600 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fas fa-angle-left"></i>
                            </button>
                            <span id="flowLogPageInfo" class="text-slate-300">Page 1 of 1</span>
                            <button id="flowLogNextPage" class="px-2 py-1 bg-slate-600 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fas fa-angle-right"></i>
                            </button>
                            <button id="flowLogLastPage" class="px-2 py-1 bg-slate-600 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fas fa-angle-double-right"></i>
                            </button>
                        </div>
                        <div class="flex items-center space-x-2">
                            <label class="text-slate-400">Show:</label>
                            <select id="flowLogPageSize" class="px-2 py-1 bg-slate-600 border border-slate-500 rounded text-slate-200">
                                <option value="50">50</option>
                                <option value="100" selected>100</option>
                                <option value="250">250</option>
                                <option value="500">500</option>
                            </select>
                            <span class="text-slate-400">per page</span>
                        </div>
                    </div>
                </div>
                <div id="flowLogContent" class="overflow-auto" style="height: calc(100% - 125px);">
                    <table class="w-full text-xs">
                        <thead class="bg-slate-700 sticky top-0 z-10">
                            <tr class="border-b border-slate-600">
                                <th class="text-left p-2 text-slate-300 font-medium">Time</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Source</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Destination</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Protocol</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Ports</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Bytes</th>
                                <th class="text-left p-2 text-slate-300 font-medium">Type</th>
                            </tr>
                        </thead>
                        <tbody id="flowLogBody" class="divide-y divide-slate-700">
                            <!-- Flow log entries will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        class TSFlowApp {
            constructor() {
                this.networkData = null;
                this.selectedDevice = null;
                this.filteredFlows = [];
                this.aggregatedFlows = [];
                this.rawFlows = [];
                this.zoom = null;
                this.svg = null;
                this.simulation = null;
                this.abortController = null;
                this.isSimulationPaused = false;
                this.currentViewMode = 'topology';
                this.minTrafficMB = 0;
                this.focusedDevice = null;
                this.focusedExternalIP = null;
                this.isSimulationStable = false;
                this.searchQuery = '';
                this.quickProtocol = '';
                this.quickTrafficMB = 0;
                this.portFilter = '';
                this.showExternalIPs = true;
                this.showVirtualTraffic = true;
                this.showPhysicalTraffic = true;
                this.showSubnetTraffic = true;
                this.showIPv4Traffic = true;
                this.showIPv6Traffic = true;
                this.flowLogCollapsed = false;
                this.flowLogEntries = [];
                this.flowLogFilters = {
                    protocol: '',
                    port: '',
                    searchQuery: '',
                    showExternal: true,
                    showIPv4: true,
                    showIPv6: true,
                    minBytes: 0
                };
                this.flowLogPagination = {
                    currentPage: 1,
                    pageSize: 100,
                    totalPages: 1,
                    totalEntries: 0
                };
                
                this.initializeApp();
            }

            initializeApp() {
                this.setupEventListeners();
                this.setupD3Visualization();
                

                const now = new Date();
                const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
                document.getElementById('endTime').value = this.formatDateTimeLocal(now);
                document.getElementById('startTime').value = this.formatDateTimeLocal(oneHourAgo);
                

                this.loadNetworkData();
            }

            setupEventListeners() {
                document.querySelectorAll('.time-preset').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const range = e.target.dataset.range;
                        this.setTimeRange(range);
                    });
                });

                document.getElementById('applyTimeRange').addEventListener('click', () => {
                    this.loadNetworkData();
                });

                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.loadNetworkData();
                });

                document.getElementById('cancelLoad').addEventListener('click', () => {
                    this.cancelLoad();
                });



                document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.currentViewMode = e.target.value;
                        this.renderVisualization();
                    });
                });

                document.getElementById('dynamicSearch').addEventListener('input', (e) => {
                    this.searchQuery = e.target.value;
                    this.applyDynamicFilters();
                });

                document.getElementById('quickFilterProtocol').addEventListener('change', (e) => {
                    this.quickProtocol = e.target.value;
                    this.applyDynamicFilters();
                });
                
                document.getElementById('quickFilterTraffic').addEventListener('change', (e) => {
                    this.quickTrafficMB = parseInt(e.target.value);
                    this.applyDynamicFilters();
                });

                document.getElementById('portFilter').addEventListener('input', (e) => {
                    this.portFilter = e.target.value;
                    this.applyDynamicFilters();
                });

                document.getElementById('showExternalIPs').addEventListener('change', (e) => {
                    this.showExternalIPs = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('showVirtualTraffic').addEventListener('change', (e) => {
                    this.showVirtualTraffic = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('showPhysicalTraffic').addEventListener('change', (e) => {
                    this.showPhysicalTraffic = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('showSubnetTraffic').addEventListener('change', (e) => {
                    this.showSubnetTraffic = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('showIPv4Traffic').addEventListener('change', (e) => {
                    this.showIPv4Traffic = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('showIPv6Traffic').addEventListener('change', (e) => {
                    this.showIPv6Traffic = e.target.checked;
                    this.applyDynamicFilters();
                });

                document.getElementById('clearAllFilters').addEventListener('click', () => {
                    this.clearAllDynamicFilters();
                });

                document.getElementById('collapseSidebar').addEventListener('click', () => {
                    this.toggleSidebar(false);
                });
                
                document.getElementById('expandSidebar').addEventListener('click', () => {
                    this.toggleSidebar(true);
                });

                document.getElementById('pauseSimulation').addEventListener('click', () => {
                    this.toggleSimulation();
                });

                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.svg.transition().duration(300).call(this.zoom.scaleBy, 1.5);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.svg.transition().duration(300).call(this.zoom.scaleBy, 0.75);
                });
                
                document.getElementById('resetZoom').addEventListener('click', () => {
                    this.svg.transition().duration(500).call(this.zoom.transform, d3.zoomIdentity);
                });

                document.getElementById('exportData').addEventListener('click', () => {
                    this.exportTailnetData();
                });

                document.getElementById('toggleFlowViewer').addEventListener('click', () => {
                    this.toggleFlowViewer();
                });

                document.getElementById('exportFlowLogs').addEventListener('click', () => {
                    this.exportFlowLogs();
                });

                // Flow log filter event listeners
                document.getElementById('flowLogSearch').addEventListener('input', (e) => {
                    this.flowLogFilters.searchQuery = e.target.value;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogProtocol').addEventListener('change', (e) => {
                    this.flowLogFilters.protocol = e.target.value;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogPort').addEventListener('input', (e) => {
                    this.flowLogFilters.port = e.target.value;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogMinBytes').addEventListener('input', (e) => {
                    this.flowLogFilters.minBytes = parseInt(e.target.value) || 0;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogShowExternal').addEventListener('change', (e) => {
                    this.flowLogFilters.showExternal = e.target.checked;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogShowIPv4').addEventListener('change', (e) => {
                    this.flowLogFilters.showIPv4 = e.target.checked;
                    this.updateFlowLogs();
                });

                document.getElementById('flowLogShowIPv6').addEventListener('change', (e) => {
                    this.flowLogFilters.showIPv6 = e.target.checked;
                    this.updateFlowLogs();
                });

                document.getElementById('clearFlowLogFilters').addEventListener('click', () => {
                    this.clearFlowLogFilters();
                });

                document.getElementById('clearFlowSelection').addEventListener('click', () => {
                    this.clearFlowHighlight();
                });

                // Flow log pagination event listeners
                document.getElementById('flowLogFirstPage').addEventListener('click', () => {
                    this.flowLogPagination.currentPage = 1;
                    this.updateFlowLogDisplay();
                });

                document.getElementById('flowLogPrevPage').addEventListener('click', () => {
                    if (this.flowLogPagination.currentPage > 1) {
                        this.flowLogPagination.currentPage--;
                        this.updateFlowLogDisplay();
                    }
                });

                document.getElementById('flowLogNextPage').addEventListener('click', () => {
                    if (this.flowLogPagination.currentPage < this.flowLogPagination.totalPages) {
                        this.flowLogPagination.currentPage++;
                        this.updateFlowLogDisplay();
                    }
                });

                document.getElementById('flowLogLastPage').addEventListener('click', () => {
                    this.flowLogPagination.currentPage = this.flowLogPagination.totalPages;
                    this.updateFlowLogDisplay();
                });

                document.getElementById('flowLogPageSize').addEventListener('change', (e) => {
                    this.flowLogPagination.pageSize = parseInt(e.target.value);
                    this.flowLogPagination.currentPage = 1; // Reset to first page
                    this.updateFlowLogDisplay();
                });
            }

            setupD3Visualization() {
                const svg = d3.select("#networkMap");
                this.svg = svg;
                

                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on("zoom", (event) => {
                        svg.select(".zoom-group").attr("transform", event.transform);
                    });
                
                svg.call(this.zoom);
                

                svg.append("g").attr("class", "zoom-group");
            }

            async loadNetworkData() {
                const startTime = performance.now();
                

                this.cancelLoad();
                

                this.abortController = new AbortController();
                
                const loading = document.getElementById('loading');
                const loadingMessage = document.getElementById('loadingMessage');
                loading.classList.remove('hidden');
                
                try {
                    const startTimeValue = document.getElementById('startTime').value;
                    const endTimeValue = document.getElementById('endTime').value;
                    
                    // Calculate adaptive timeout based on time range
                    let timeoutMs = 60000; // Default 60 seconds
                    if (startTimeValue && endTimeValue) {
                        const start = new Date(startTimeValue);
                        const end = new Date(endTimeValue);
                        const diffHours = (end - start) / (1000 * 60 * 60);
                        
                        // Adaptive timeout based on time range
                        if (diffHours <= 0.5) { // 30 minutes or less
                            timeoutMs = 15000; // 15 seconds for <= 30 minutes
                        } else if (diffHours <= 1) {
                            timeoutMs = 30000; // 30 seconds for <= 1 hour
                        } else if (diffHours <= 6) {
                            timeoutMs = 60000; // 60 seconds for <= 6 hours
                        } else {
                            timeoutMs = 120000; // 2 minutes for > 6 hours
                        }
                        
                        // Show loading message with estimated time
                        if (diffHours > 3) {
                            loadingMessage.textContent = `Fetching ${Math.round(diffHours)}h of data... (may take ${Math.round(timeoutMs/1000)}s)`;
                        } else {
                            loadingMessage.textContent = 'Fetching Tailnet data...';
                        }
                    }
                    
                    let url = '/api/network-map';
                    if (startTimeValue && endTimeValue) {
                        const start = new Date(startTimeValue).toISOString();
                        const end = new Date(endTimeValue).toISOString();
                        url += `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;
                    }
                    
                    const response = await this.fetchWithTimeout(url, {
                        signal: this.abortController.signal
                    }, timeoutMs);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    loadingMessage.textContent = 'Processing Tailnet flows...';
                    
                    this.networkData = await response.json();
                    this.rawFlows = this.networkData.rawFlows || [];
                    this.updateDevicesList();
                    this.applyDynamicFilters();
                    this.updateStats();
                    
                    const loadTime = ((performance.now() - startTime) / 1000).toFixed(1);
                    document.getElementById('loadTime').textContent = `${loadTime}s`;
                    
                    this.clearMessage();
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.showMessage('warning', 'Request was cancelled.');
                    } else if (error.name === 'TimeoutError') {
                        const startTimeValue = document.getElementById('startTime').value;
                        const endTimeValue = document.getElementById('endTime').value;
                        let helpText = 'Request timed out. Try a smaller time range.';
                        
                        if (startTimeValue && endTimeValue) {
                            const diffHours = (new Date(endTimeValue) - new Date(startTimeValue)) / (1000 * 60 * 60);
                            if (diffHours > 6) {
                                helpText = `${Math.round(diffHours)}h is a large time range. Try limiting to 6h or less, or wait longer for processing.`;
                            } else if (diffHours > 3) {
                                helpText = `${Math.round(diffHours)}h time range timed out. Backend may be busy - try again or use a smaller range.`;
                            }
                        }
                        
                        this.showMessage('error', helpText);
                    } else {
                        this.showMessage('error', 'Failed to load Tailnet data: ' + error.message);
                    }
                } finally {
                    loading.classList.add('hidden');
                    this.abortController = null;
                }
            }

            async fetchWithTimeout(url, options = {}, timeout = 60000) {
                return Promise.race([
                    fetch(url, options),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('TimeoutError')), timeout)
                    )
                ]);
            }

            cancelLoad() {
                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }
            }

            showMessage(type, message) {
                const messageArea = document.getElementById('messageArea');
                const className = type === 'error' ? 'error-message' : 'warning-message';
                
                messageArea.innerHTML = `
                    <div class="flex items-center justify-between p-3 rounded-lg ${className}">
                        <div class="flex items-center">
                            <i class="fas fa-${type === 'error' ? 'exclamation-circle' : 'exclamation-triangle'} mr-2"></i>
                            <span>${message}</span>
                        </div>
                        <button onclick="this.parentElement.parentElement.classList.add('hidden')" class="ml-4">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                messageArea.classList.remove('hidden');
            }

            clearMessage() {
                document.getElementById('messageArea').classList.add('hidden');
            }

            toggleSimulation() {
                const btn = document.getElementById('pauseSimulation');
                const icon = btn.querySelector('i');
                
                if (this.simulation) {
                    if (this.isSimulationPaused) {
                        this.simulation.restart();
                        icon.className = 'fas fa-pause';
                        this.isSimulationPaused = false;
                    } else {
                        this.simulation.stop();
                        icon.className = 'fas fa-play';
                        this.isSimulationPaused = true;
                    }
                }
            }

            updateDevicesList() {
                const devicesList = document.getElementById('devicesList');
                devicesList.innerHTML = '';
                
                if (!this.networkData || !this.networkData.devices) return;
                
                // Only show machines that have flows
                const devicesWithFlows = this.networkData.devices.filter(device => {
                    return this.networkData.flows.some(flow => 
                        flow.sourceDevice?.id === device.id || 
                        flow.destinationDevice?.id === device.id ||
                        device.addresses?.some(addr => {
                            const ip = addr.split('/')[0];
                            return flow.sourceIP === ip || flow.destinationIP === ip;
                        })
                    );
                });
                
                devicesWithFlows.forEach(device => {
                    const deviceElement = document.createElement('div');
                    const isFocused = this.focusedDevice?.id === device.id;
                    const isSelected = this.selectedDevice?.id === device.id;
                    
                    // Determine machine type for Tailscale styling
                    let machineType = '';
                    let machineIcon = 'ðŸ’»';
                    if (device.tags?.includes('exit-node') || device.tags?.includes('exitnode')) {
                        machineType = 'exit-node';
                        machineIcon = 'ðŸš€';
                    } else if (device.tags?.includes('subnet-router') || device.tags?.includes('router')) {
                        machineType = 'subnet-router';
                        machineIcon = 'ðŸŒ';
                    } else if (device.tags?.includes('ssh') || device.tags?.includes('server')) {
                        machineIcon = 'ðŸ–¥ï¸';
                    } else if (device.os?.toLowerCase().includes('ios') || device.os?.toLowerCase().includes('android')) {
                        machineIcon = 'ðŸ“±';
                    }

                    // Simple online status determination
                    const isOnline = this.isDeviceOnline(device);

                    deviceElement.className = `machine-card p-2 rounded cursor-pointer transition-all ${
                        isOnline ? 'online' : ''
                    } ${
                        isSelected ? 'selected' : ''
                    } ${
                        machineType === 'exit-node' ? 'exit-node' : ''
                    } ${
                        machineType === 'subnet-router' ? 'subnet-router' : ''
                    }`;
                    
                    // Count IPv4 and IPv6 addresses
                    const ipv4Count = device.addresses?.filter(addr => !this.isIPv6(addr.split('/')[0])).length || 0;
                    const ipv6Count = device.addresses?.filter(addr => this.isIPv6(addr.split('/')[0])).length || 0;
                    
                    const deviceName = (device.name || device.hostname || 'Unknown').length > 16 
                        ? (device.name || device.hostname || 'Unknown').substring(0, 13) + '...' 
                        : (device.name || device.hostname || 'Unknown');
                    
                    // Show tags with proper truncation and containment
                    const tagsHtml = device.tags && device.tags.length > 0 
                        ? `<div class="flex flex-wrap gap-1 mt-1 max-w-full overflow-hidden">${device.tags.map(tag => 
                            `<span class="tag-badge px-1 py-0.5 rounded text-xs">${tag.length > 8 ? tag.substring(0, 6) + '..' : tag}</span>`
                          ).join('')}</div>`
                        : '';

                    deviceElement.innerHTML = `
                        <div class="flex items-start space-x-2 w-full overflow-hidden">
                            <div class="${isOnline ? 'connected-dot' : 'disconnected-dot'} mt-1"></div>
                            <div class="flex-1 min-w-0 overflow-hidden">
                                <div class="flex items-center space-x-2 mb-1">
                                    <div class="font-medium text-sm truncate flex-1">${deviceName}</div>
                                    ${machineType === 'exit-node' ? '<span class="text-xs bg-yellow-600 text-yellow-100 px-1 py-0.5 rounded whitespace-nowrap">Exit</span>' : ''}
                                    ${machineType === 'subnet-router' ? '<span class="text-xs bg-green-600 text-green-100 px-1 py-0.5 rounded whitespace-nowrap">Router</span>' : ''}
                                </div>
                                                                    <div class="text-xs text-slate-400 truncate">
                                        ${device.os || 'Unknown'} â€¢ ${ipv4Count + ipv6Count} IP${ipv4Count + ipv6Count !== 1 ? 's' : ''}${isFocused ? ' â€¢ Focused' : ''}
                                    </div>
                                    ${tagsHtml}
                            </div>
                        </div>
                    `;
                    
                    deviceElement.addEventListener('click', () => {
                        this.selectDevice(device);
                        this.focusOnDevice(device);
                    });
                    
                    devicesList.appendChild(deviceElement);
                });
            }

            selectDevice(device) {
                this.selectedDevice = device;
                this.showDeviceDetails(device);
                this.highlightDeviceFlows(device);
            }

            focusOnDevice(device) {
                if (this.focusedDevice?.id === device.id) {
                    // If clicking the same device, clear focus
                    this.focusedDevice = null;
                } else {
                    // Focus on new device
                    this.focusedDevice = device;
                    // Clear external IP focus if any
                    this.focusedExternalIP = null;
                }
                // Update flow logs to reflect focus change
                this.updateFlowLogs();
                this.applyDynamicFilters();
            }

            focusOnExternalIP(ip) {
                if (this.focusedExternalIP === ip) {
                    // If clicking the same IP, clear focus
                    this.focusedExternalIP = null;
                } else {
                    // Focus on new external IP
                    this.focusedExternalIP = ip;
                    // Clear device focus if any
                    this.focusedDevice = null;
                    this.selectedDevice = null;
                    // Hide device details panel
                    document.getElementById('deviceDetails').classList.add('hidden');
                }
                // Update devices list to remove selection styling
                this.updateDevicesList();
                // Update flow logs to reflect focus change
                this.updateFlowLogs();
                this.applyDynamicFilters();
            }

            showDeviceDetails(device) {
                const deviceDetails = document.getElementById('deviceDetails');
                const deviceInfo = document.getElementById('deviceInfo');
                
                // Separate IPv4 and IPv6 addresses
                const ipv4Addresses = device.addresses?.filter(addr => !this.isIPv6(addr.split('/')[0])) || [];
                const ipv6Addresses = device.addresses?.filter(addr => this.isIPv6(addr.split('/')[0])) || [];
                
                // Count flows involving this machine
                const machineFlows = this.networkData.flows.filter(flow => 
                    flow.sourceDevice?.id === device.id || flow.destinationDevice?.id === device.id
                );
                
                const totalTraffic = machineFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                
                // Simple online status determination
                const isOnline = this.isDeviceOnline(device);
                
                // Determine machine role
                let machineRole = 'Standard Machine';
                if (device.tags?.includes('exit-node') || device.tags?.includes('exitnode')) {
                    machineRole = 'Exit Node';
                } else if (device.tags?.includes('subnet-router') || device.tags?.includes('router')) {
                    machineRole = 'Subnet Router';
                } else if (device.tags?.includes('ssh') || device.tags?.includes('server')) {
                    machineRole = 'SSH Server';
                }
                
                deviceInfo.innerHTML = `
                    <div class="bg-slate-800 p-3 rounded-lg border border-slate-600">
                        <div class="flex items-center justify-between mb-2">
                            <div class="font-medium text-slate-100">${device.name || device.hostname}</div>
                            <div class="flex items-center space-x-2">
                                ${this.focusedDevice?.id === device.id ? 
                                    '<button onclick="window.tsflowApp.clearDeviceFocus()" class="text-xs bg-orange-600 hover:bg-orange-500 text-white px-2 py-1 rounded">ðŸŽ¯ Clear Focus</button>' : 
                                    '<button onclick="window.tsflowApp.focusOnDevice(window.tsflowApp.selectedDevice)" class="text-xs text-blue-400 hover:text-blue-300">Focus View</button>'
                                }
                                ${this.focusedExternalIP ? 
                                    '<button onclick="window.tsflowApp.clearDeviceFocus()" class="text-xs bg-orange-600 hover:bg-orange-500 text-white px-2 py-1 rounded">ðŸŽ¯ Clear IP Focus</button>' : ''
                                }
                                <button onclick="window.tsflowApp.clearDeviceFocus()" class="text-xs text-slate-400 hover:text-slate-300">âœ•</button>
                            </div>
                        </div>
                        <div class="space-y-1 text-sm">
                            <div><span class="font-medium text-slate-300">Status:</span> 
                                <span class="${isOnline ? 'text-green-400' : 'text-slate-500'}">${isOnline ? 'ðŸŸ¢ Online' : 'ðŸ”´ Offline'}</span>
                            </div>
                            <div><span class="font-medium text-slate-300">Role:</span> <span class="text-slate-200">${machineRole}</span></div>
                            <div><span class="font-medium text-slate-300">OS:</span> <span class="text-slate-200">${device.os || 'Unknown'}</span></div>
                            <div><span class="font-medium text-slate-300">User:</span> <span class="text-slate-200">${device.user || 'N/A'}</span></div>
                            <div><span class="font-medium text-slate-300">Flows:</span> <span class="text-slate-200">${machineFlows.length}</span></div>
                            <div><span class="font-medium text-slate-300">Traffic Volume:</span> <span class="text-blue-400">${this.formatBytes(totalTraffic)}</span></div>
                            
                            ${device.tags && device.tags.length > 0 ? `
                                <div><span class="font-medium text-slate-300">Tags:</span></div>
                                <div class="flex flex-wrap gap-1 ml-4 max-w-full overflow-hidden">
                                    ${device.tags.map(tag => `<span class="tag-badge px-1 py-0.5 rounded text-xs">${tag.length > 8 ? tag.substring(0, 6) + '..' : tag}</span>`).join('')}
                                </div>
                            ` : ''}
                            
                            ${ipv4Addresses.length > 0 ? `
                                <div><span class="font-medium text-slate-300">IPv4:</span></div>
                                ${ipv4Addresses.map(addr => `<div class="ml-4 text-xs text-slate-400">ðŸ“ ${addr}</div>`).join('')}
                            ` : ''}
                            
                            ${ipv6Addresses.length > 0 ? `
                                <div><span class="font-medium text-slate-300">IPv6:</span></div>
                                ${ipv6Addresses.map(addr => `<div class="ml-4 text-xs text-slate-400">ðŸŒ ${addr}</div>`).join('')}
                            ` : ''}
                        </div>
                    </div>
                `;
                
                deviceDetails.classList.remove('hidden');
            }

            clearDeviceFocus() {
                this.focusedDevice = null;
                this.focusedExternalIP = null;
                this.selectedDevice = null;
                
                // Hide device details panel
                document.getElementById('deviceDetails').classList.add('hidden');
                
                // Update devices list to remove selection styling
                this.updateDevicesList();
                
                // Update flow logs since focus changed
                this.updateFlowLogs();
                
                this.applyDynamicFilters();
            }

            highlightDeviceFlows(device) {
                // Highlight flows related to the selected device
                this.renderVisualization();
            }

            applyDynamicFilters() {
                if (!this.networkData?.flows) return;
                
                let filtered = this.networkData.flows.filter(flow => {
                    // Flow type filter
                    if (!this.showVirtualTraffic && flow.flowType === 'virtual') return false;
                    if (!this.showPhysicalTraffic && flow.flowType === 'physical') return false;
                    if (!this.showSubnetTraffic && flow.flowType === 'subnet') return false;
                    
                    // Quick protocol filter
                    if (this.quickProtocol) {
                        if (this.quickProtocol === 'proto-0') {
                            // Handle proto-0 specifically (could be "0", "proto-0", or similar)
                            if (flow.protocol !== 'proto-0' && flow.protocol !== '0') return false;
                        } else if (flow.protocol !== this.quickProtocol) {
                            return false;
                        }
                    }
                    
                    // Port filter
                    if (this.portFilter) {
                        const ports = this.portFilter.split(',').map(p => p.trim()).filter(p => p);
                        if (ports.length > 0) {
                            const hasPort = ports.some(port => flow.port === port);
                            if (!hasPort) return false;
                        }
                    }
                    
                    // Quick traffic filter
                    const trafficMB = (flow.totalBytes || 0) / (1024 * 1024);
                    if (this.quickTrafficMB > 0 && trafficMB < this.quickTrafficMB) return false;
                    
                    // External IPs filter
                    if (!this.showExternalIPs) {
                        // Only show flows between known devices (both source and destination must have device info)
                        if (!flow.sourceDevice || !flow.destinationDevice) return false;
                    }
                    
                    // IPv4/IPv6 filter
                    const hasIPv4 = !this.isIPv6(flow.sourceIP) || !this.isIPv6(flow.destinationIP);
                    const hasIPv6 = this.isIPv6(flow.sourceIP) || this.isIPv6(flow.destinationIP);
                    
                    if (!this.showIPv4Traffic && hasIPv4 && !hasIPv6) return false;
                    if (!this.showIPv6Traffic && hasIPv6 && !hasIPv4) return false;
                    
                    // Focus device filter (when a device is selected)
                    if (this.focusedDevice) {
                        const isConnected = (flow.sourceDevice?.id === this.focusedDevice.id) ||
                                          (flow.destinationDevice?.id === this.focusedDevice.id) ||
                                          (flow.sourceIP === this.getDeviceMainIP(this.focusedDevice)) ||
                                          (flow.destinationIP === this.getDeviceMainIP(this.focusedDevice));
                        if (!isConnected) return false;
                    }
                    
                    // Focus external IP filter (when an external IP is selected)
                    if (this.focusedExternalIP) {
                        const isConnected = (flow.sourceIP === this.focusedExternalIP) ||
                                          (flow.destinationIP === this.focusedExternalIP);
                        if (!isConnected) return false;
                    }
                    
                    // Dynamic search query
                    if (this.searchQuery) {
                        return this.matchesSearchQuery(flow, this.searchQuery);
                    }
                    
                    return true;
                });
                
                // Sort by total bytes (descending) to prioritize high-volume flows
                filtered.sort((a, b) => (b.totalBytes || 0) - (a.totalBytes || 0));
                
                this.clearMessage();
                
                this.filteredFlows = filtered;
                this.renderVisualization();
                this.updateStats();
                
                // Sync certain graph filters to flow log filters
                this.syncFiltersToFlowLogs();
                
                this.updateFlowLogs();
            }

            matchesSearchQuery(flow, query) {
                const lowerQuery = query.toLowerCase();
                
                // Handle special search syntax
                if (lowerQuery.includes(':')) {
                    const parts = lowerQuery.split(' ').filter(p => p.includes(':'));
                    for (const part of parts) {
                        const [key, value] = part.split(':');
                        
                        switch (key) {
                            case 'protocol':
                                if (flow.protocol.toLowerCase() !== value) return false;
                                break;
                            case 'port':
                                if (flow.port !== value) return false;
                                break;
                            case 'tag':
                                const hasTag = (flow.sourceDevice?.tags || []).concat(flow.destinationDevice?.tags || [])
                                    .some(tag => tag.toLowerCase().includes(value));
                                if (!hasTag) return false;
                                break;
                            case 'ip':
                                // Filter by specific IP address
                                if (flow.sourceIP !== value && flow.destinationIP !== value) return false;
                                break;
                            case 'traffic':
                                const trafficMB = (flow.totalBytes || 0) / (1024 * 1024);
                                if (value.startsWith('>')) {
                                    const threshold = parseFloat(value.substring(1).replace('mb', '').replace('gb', '000'));
                                    if (trafficMB <= threshold) return false;
                                } else if (value.startsWith('<')) {
                                    const threshold = parseFloat(value.substring(1).replace('mb', '').replace('gb', '000'));
                                    if (trafficMB >= threshold) return false;
                                }
                                break;
                            case 'type':
                                if (value === 'external') {
                                    const hasSourceDevice = flow.sourceDevice !== null;
                                    const hasDestDevice = flow.destinationDevice !== null;
                                    if (hasSourceDevice && hasDestDevice) return false;
                                } else if (value === 'internal') {
                                    const hasSourceDevice = flow.sourceDevice !== null;
                                    const hasDestDevice = flow.destinationDevice !== null;
                                    if (!hasSourceDevice || !hasDestDevice) return false;
                                }
                                break;
                            case 'has':
                                if (value === 'tags') {
                                    const hasTags = (flow.sourceDevice?.tags?.length > 0) || (flow.destinationDevice?.tags?.length > 0);
                                    if (!hasTags) return false;
                                }
                                break;
                        }
                    }
                    
                    // Remove special syntax for general search
                    const generalQuery = lowerQuery.replace(/\w+:[^\s]+/g, '').trim();
                    if (!generalQuery) return true;
                    query = generalQuery;
                }
                
                // General text search
                const searchText = [
                    flow.sourceIP,
                    flow.destinationIP,
                    flow.sourceDevice?.name,
                    flow.sourceDevice?.hostname,
                    flow.destinationDevice?.name,
                    flow.destinationDevice?.hostname,
                    flow.protocol,
                    flow.port,
                    ...(flow.sourceDevice?.tags || []),
                    ...(flow.destinationDevice?.tags || [])
                ].filter(Boolean).join(' ').toLowerCase();
                
                return searchText.includes(query.toLowerCase());
            }

            clearAllDynamicFilters() {
                document.getElementById('dynamicSearch').value = '';
                document.getElementById('quickFilterProtocol').value = '';
                document.getElementById('quickFilterTraffic').value = '0';
                document.getElementById('portFilter').value = '';
                document.getElementById('showExternalIPs').checked = true;
                document.getElementById('showVirtualTraffic').checked = true;
                document.getElementById('showPhysicalTraffic').checked = true;
                document.getElementById('showSubnetTraffic').checked = true;
                document.getElementById('showIPv4Traffic').checked = true;
                document.getElementById('showIPv6Traffic').checked = true;
                this.searchQuery = '';
                this.quickProtocol = '';
                this.quickTrafficMB = 0;
                this.portFilter = '';
                this.showExternalIPs = true;
                this.showVirtualTraffic = true;
                this.showPhysicalTraffic = true;
                this.showSubnetTraffic = true;
                this.showIPv4Traffic = true;
                this.showIPv6Traffic = true;
                this.focusedDevice = null;
                this.focusedExternalIP = null;
                this.selectedDevice = null;
                this.flowLogCollapsed = false;
                this.flowLogEntries = [];
                
                // Clear device details panel
                document.getElementById('deviceDetails').classList.add('hidden');
                
                // Update devices list to remove selection styling
                this.updateDevicesList();
                
                // Also clear flow log filters to match
                this.flowLogFilters.protocol = '';
                this.flowLogFilters.port = '';
                this.flowLogFilters.showExternal = true;
                this.flowLogFilters.showIPv4 = true;
                this.flowLogFilters.showIPv6 = true;
                
                // Update flow log filter UI
                document.getElementById('flowLogProtocol').value = '';
                document.getElementById('flowLogPort').value = '';
                document.getElementById('flowLogShowExternal').checked = true;
                document.getElementById('flowLogShowIPv4').checked = true;
                document.getElementById('flowLogShowIPv6').checked = true;
                
                // Reset flow log pagination
                this.flowLogPagination.currentPage = 1;
                
                this.applyDynamicFilters();
            }

            syncFiltersToFlowLogs() {
                // Sync protocol filter
                if (this.quickProtocol !== this.flowLogFilters.protocol) {
                    this.flowLogFilters.protocol = this.quickProtocol;
                    document.getElementById('flowLogProtocol').value = this.quickProtocol;
                }
                
                // Sync port filter  
                if (this.portFilter !== this.flowLogFilters.port) {
                    this.flowLogFilters.port = this.portFilter;
                    document.getElementById('flowLogPort').value = this.portFilter;
                }
                
                // Sync external IPs filter
                if (this.showExternalIPs !== this.flowLogFilters.showExternal) {
                    this.flowLogFilters.showExternal = this.showExternalIPs;
                    document.getElementById('flowLogShowExternal').checked = this.showExternalIPs;
                }
                
                // Sync IPv4/IPv6 filters
                if (this.showIPv4Traffic !== this.flowLogFilters.showIPv4) {
                    this.flowLogFilters.showIPv4 = this.showIPv4Traffic;
                    document.getElementById('flowLogShowIPv4').checked = this.showIPv4Traffic;
                }
                
                if (this.showIPv6Traffic !== this.flowLogFilters.showIPv6) {
                    this.flowLogFilters.showIPv6 = this.showIPv6Traffic;
                    document.getElementById('flowLogShowIPv6').checked = this.showIPv6Traffic;
                }
                
                // Reset pagination when filters change
                this.flowLogPagination.currentPage = 1;
            }

            setQuickFilter(query) {
                document.getElementById('dynamicSearch').value = query;
                this.searchQuery = query;
                this.applyDynamicFilters();
            }



            isIPv6(ip) {
                return ip && ip.includes(':');
            }

            getDeviceMainIP(device) {
                if (!device?.addresses) return null;
                return device.addresses[0]?.split('/')[0];
            }

            isDeviceOnline(device) {
                if (!device) return false;
                
                // Check if we have explicit online status from API
                if (typeof device.online === 'boolean') {
                    // If API says online, trust it
                    if (device.online) return true;
                    
                                                // If API says offline, but device was seen recently, consider it online
                            if (device.lastSeen) {
                                try {
                                    const lastSeenDate = new Date(device.lastSeen);
                                    const now = new Date();
                                    const diffMinutes = (now - lastSeenDate) / (1000 * 60);
                                    
                                    // Consider online if seen within last 5 minutes (more strict)
                                    if (diffMinutes < 5) {
                                        return true;
                                    }
                                    
                                    return false;
                                } catch (error) {
                                    return false;
                                }
                            }
                    
                    // API says offline and no lastSeen data
                    return false;
                }
                
                // If online field is a string, handle common string values
                if (typeof device.online === 'string') {
                    const onlineStr = device.online.toLowerCase();
                    if (onlineStr === 'true' || onlineStr === 'online') return true;
                    if (onlineStr === 'false' || onlineStr === 'offline') {
                        // Same logic as boolean false - check lastSeen
                        if (device.lastSeen) {
                            try {
                                const lastSeenDate = new Date(device.lastSeen);
                                const now = new Date();
                                const diffMinutes = (now - lastSeenDate) / (1000 * 60);
                                return diffMinutes < 5;
                            } catch (error) {
                                return false;
                            }
                        }
                        return false;
                    }
                }
                
                // Fallback to lastSeen only if we have it (no explicit online field)
                if (device.lastSeen) {
                    try {
                        const lastSeenDate = new Date(device.lastSeen);
                        const now = new Date();
                        const diffMinutes = (now - lastSeenDate) / (1000 * 60);
                        
                        // Consider online if seen within last 15 minutes
                        return diffMinutes < 15;
                    } catch (error) {
                        return false;
                    }
                }
                
                // If we have no status info, assume offline
                return false;
            }

            createLinksFromFlows(nodeMap) {
                // Aggregate flows between same node pairs for cleaner visualization
                // Also handle cases where the same machine has multiple IPs (LAN + Tailscale)
                const linkMap = new Map();
                this.filteredFlows.forEach(flow => {
                    // Try to find source and target nodes, preferring device mapping over IP mapping
                    let source = null;
                    let target = null;
                    
                    // Check for device-based mapping first (more reliable for LAN IP aggregation)
                    if (flow.sourceDevice?.id) {
                        source = nodeMap.get(flow.sourceDevice.id);
                    }
                    if (!source) {
                        source = nodeMap.get(flow.sourceIP);
                    }
                    
                    if (flow.destinationDevice?.id) {
                        target = nodeMap.get(flow.destinationDevice.id);
                    }
                    if (!target) {
                        target = nodeMap.get(flow.destinationIP);
                    }
                    
                    if (source && target && source !== target) {
                        // Create a consistent link key for bidirectional aggregation
                        const linkKey = source.id < target.id ? `${source.id}->${target.id}` : `${target.id}->${source.id}`;
                        
                        let linkData = linkMap.get(linkKey);
                        if (linkData) {
                            linkData.totalBytes += flow.totalBytes || 0;
                            linkData.flowCount += flow.flowCount || 1;
                            linkData.flows.push(flow);
                            linkData.protocols.add(flow.protocol);
                            linkData.flowTypes.add(flow.flowType);
                        } else {
                            linkMap.set(linkKey, {
                                source: source,
                                target: target,
                                totalBytes: flow.totalBytes || 0,
                                flowCount: flow.flowCount || 1,
                                flows: [flow],
                                protocols: new Set([flow.protocol]),
                                flowTypes: new Set([flow.flowType])
                            });
                        }
                    }
                });

                return Array.from(linkMap.values())
                    .sort((a, b) => b.totalBytes - a.totalBytes);
            }

            renderNodesAndLinks(svg, nodes, links) {
                // Create links
                const link = svg.append("g")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("class", "flow-line")
                    .attr("stroke", d => {
                        // Handle mixed protocols
                        if (d.protocols.size > 1) return "#8b5cf6";
                        
                        // Single protocol colors
                        if (d.protocols.has('TCP')) return "#3b82f6";
                        if (d.protocols.has('UDP')) return "#10b981";
                        if (d.protocols.has('ICMP')) return "#f59e0b";
                        if (d.protocols.has('RAW')) return "#8b5cf6";
                        if (d.protocols.has('proto-0')) return "#6b7280";
                        
                        return "#6b7280";
                    })
                    .attr("stroke-dasharray", d => {
                        // Apply dash pattern based on flow type
                        if (d.flowTypes.has('subnet')) return "5,5";
                        if (d.flowTypes.has('virtual')) return "2,2";
                        return "none"; // Physical traffic - solid line
                    })
                    .attr("stroke-width", d => {
                        const maxBytesInView = Math.max(...links.map(l => l.totalBytes || 1));
                        const ratio = (d.totalBytes || 1) / maxBytesInView;
                                        const scaledRatio = Math.pow(ratio, 0.3);
                return 1 + 19 * scaledRatio;
                    })
                    .attr("opacity", d => Math.min(0.9, 0.3 + (d.flowCount / 10)))
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y)
                    .on("mouseover", (event, d) => {
                        this.showFlowTooltip(event, d);
                    })
                    .on("mouseout", () => {
                        this.hideTooltip();
                    });
                
                // Create nodes
                const node = svg.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .style("cursor", "pointer")
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        if (d.device) {
                            this.selectDevice(d.device);
                            this.focusOnDevice(d.device);
                        }
                    });
                
                // Add metadata boxes for devices (same as in topology view)
                this.renderDeviceMetadataBoxes(node.filter(d => d.type === 'device'));
                
                // Add simple circles for external nodes (same as in topology view)
                this.renderExternalNodes(node.filter(d => d.type === 'external'));
            }



            detectClusters(nodes, nodeConnections, links) {
                // Simple community detection based on shared connections
                const clusters = [];
                const visited = new Set();
                
                // Start with highest degree nodes as cluster seeds
                const sortedNodes = nodes
                    .filter(n => n.type === 'device') // Only cluster devices, not external IPs
                    .sort((a, b) => (nodeConnections.get(b.id)?.size || 0) - (nodeConnections.get(a.id)?.size || 0));
                
                for (let seed of sortedNodes) {
                    if (visited.has(seed.id)) continue;
                    
                    const cluster = [];
                    const queue = [seed.id];
                    const clusterNodes = new Set();
                    
                    while (queue.length > 0 && cluster.length < 8) { // Limit cluster size
                        const nodeId = queue.shift();
                        if (visited.has(nodeId) || clusterNodes.has(nodeId)) continue;
                        
                        cluster.push(nodeId);
                        clusterNodes.add(nodeId);
                        visited.add(nodeId);
                        
                        // Add strongly connected neighbors
                        const connections = nodeConnections.get(nodeId) || new Set();
                        for (let neighbor of connections) {
                            if (!visited.has(neighbor) && !clusterNodes.has(neighbor)) {
                                // Check if this neighbor has many connections to current cluster
                                const neighborConnections = nodeConnections.get(neighbor) || new Set();
                                let sharedConnections = 0;
                                for (let clusterId of clusterNodes) {
                                    if (neighborConnections.has(clusterId)) sharedConnections++;
                                }
                                
                                // Add if highly connected to this cluster
                                if (sharedConnections >= Math.max(1, clusterNodes.size * 0.3)) {
                                    queue.push(neighbor);
                                }
                            }
                        }
                    }
                    
                    if (cluster.length > 0) {
                        clusters.push(cluster);
                    }
                }
                
                // Handle remaining unvisited nodes
                const unvisited = nodes.filter(n => n.type === 'device' && !visited.has(n.id));
                if (unvisited.length > 0) {
                    clusters.push(unvisited.map(n => n.id));
                }
                

                return clusters;
            }

            calculateClusterPositions(clusters, nodeConnections, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Calculate cluster connectivity and size
                const clusterData = clusters.map((cluster, index) => {
                    const connectivity = cluster.reduce((total, nodeId) => {
                        return total + (nodeConnections.get(nodeId)?.size || 0);
                    }, 0);
                    return { 
                        cluster, 
                        connectivity, 
                        size: cluster.length, 
                        index,
                        // Combined importance score
                        importance: connectivity + (cluster.length * 2)
                    };
                });
                
                // Sort by importance (connectivity + size)
                clusterData.sort((a, b) => b.importance - a.importance);
                
                const positions = [];
                const numClusters = clusters.length;
                
                // More intuitive, closer positioning
                if (numClusters === 1) {
                    positions.push({ x: centerX, y: centerY });
                } else {
                    // Place most important cluster at center
                    positions.push({ x: centerX, y: centerY });
                    
                    // For remaining clusters, use a tight spiral pattern
                    const baseRadius = Math.min(width, height) * 0.15; // Much smaller base radius
                    const radiusIncrement = baseRadius * 0.3; // Gentle radius increase
                    
                    for (let i = 1; i < numClusters; i++) {
                        // Spiral outward with golden angle for even distribution
                        const angle = i * 2.39996; // Golden angle in radians
                        const radius = baseRadius + Math.sqrt(i) * radiusIncrement;
                        
                        positions.push({
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        });
                    }
                }
                
                // Map positions back to original cluster order
                const orderedPositions = new Array(numClusters);
                clusterData.forEach((cluster, sortedIndex) => {
                    orderedPositions[cluster.index] = positions[sortedIndex];
                });
                
                return orderedPositions;
            }



            renderVisualization() {
                switch (this.currentViewMode) {
                    case 'topology':
                        this.renderNetworkTopology();
                        break;
                    case 'circular':
                        this.renderCircularLayout();
                        break;
                    case 'grid':
                        this.renderGridLayout();
                        break;
                    default:
                        this.renderNetworkTopology();
                }
            }

            renderNetworkTopology() {
                if (!this.networkData) return;
                
                // Stop existing simulation
                if (this.simulation) {
                    this.simulation.stop();
                }
                
                const svg = this.svg.select(".zoom-group");
                svg.selectAll("*").remove();
                
                const width = document.getElementById('networkMap').clientWidth;
                const height = document.getElementById('networkMap').clientHeight;
                
                // Create nodes from devices and external IPs
                const nodes = [];
                const nodeMap = new Map();
                
                // Only include devices that have flows
                const devicesWithFlows = this.networkData.devices.filter(device => {
                    return this.filteredFlows.some(flow => 
                        flow.sourceDevice?.id === device.id || 
                        flow.destinationDevice?.id === device.id ||
                        device.addresses?.some(addr => {
                            const ip = addr.split('/')[0];
                            return flow.sourceIP === ip || flow.destinationIP === ip;
                        })
                    );
                });
                
                // Use all devices with flows (no artificial limit)
                const devices = devicesWithFlows;
                
                devices.forEach((device, i) => {
                    const node = {
                        id: device.id,
                        name: device.name || device.hostname,
                        type: 'device',
                        device: device,
                        x: width / 2 + (Math.random() - 0.5) * 200, // Will be repositioned by cluster
                        y: height / 2 + (Math.random() - 0.5) * 200
                    };
                    nodes.push(node);
                    nodeMap.set(device.id, node);
                    
                    // Also map by IP addresses
                    device.addresses?.forEach(addr => {
                        const ip = addr.split('/')[0];
                        nodeMap.set(ip, node);
                    });
                });
                
                // Add external IP nodes (REMOVED LIMITATION)
                const externalIPs = new Set();
                this.filteredFlows.forEach(flow => {
                    if (!nodeMap.has(flow.sourceIP)) {
                        externalIPs.add(flow.sourceIP);
                    }
                    if (!nodeMap.has(flow.destinationIP)) {
                        externalIPs.add(flow.destinationIP);
                    }
                });
                
                // Show ALL external IPs that have flows
                Array.from(externalIPs).forEach((ip, i) => {
                    // Place external IPs in expanding circles for better distribution
                    const ring = Math.floor(i / 12); // 12 IPs per ring
                    const angleStep = (2 * Math.PI) / Math.min(12, externalIPs.size - (ring * 12));
                    const angle = (i % 12) * angleStep;
                    const baseRadius = Math.min(width, height) * 0.4;
                    const radius = baseRadius + (ring * 60); // Expand rings outward
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    const node = {
                        id: ip,
                        name: ip,
                        type: 'external',
                        x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 40,
                        y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 40
                    };
                    nodes.push(node);
                    nodeMap.set(ip, node);
                });
                
                // Aggregate flows between same node pairs for cleaner visualization
                const linkMap = new Map();
                let missingSourceNodes = 0;
                let missingTargetNodes = 0;
                
                this.filteredFlows.forEach(flow => {
                    // Enhanced node mapping: try multiple approaches to find source and target
                    let source = null;
                    let target = null;
                    
                    // Try device ID first, then IP address
                    if (flow.sourceDevice?.id) {
                        source = nodeMap.get(flow.sourceDevice.id);
                    }
                    if (!source && flow.sourceIP) {
                        source = nodeMap.get(flow.sourceIP);
                    }
                    
                    if (flow.destinationDevice?.id) {
                        target = nodeMap.get(flow.destinationDevice.id);
                    }
                    if (!target && flow.destinationIP) {
                        target = nodeMap.get(flow.destinationIP);
                    }
                    
                    // Track missing nodes
                    if (!source) {
                        missingSourceNodes++;
                    }
                    if (!target) {
                        missingTargetNodes++;
                    }
                    
                    if (source && target && source !== target) {
                        // Create a consistent link key for bidirectional aggregation
                        const linkKey = source.id < target.id ? `${source.id}->${target.id}` : `${target.id}->${source.id}`;
                        
                        let linkData = linkMap.get(linkKey);
                        if (linkData) {
                            linkData.totalBytes += flow.totalBytes || 0;
                            linkData.flowCount += flow.flowCount || 1;
                            linkData.flows.push(flow);
                            linkData.protocols.add(flow.protocol);
                            linkData.flowTypes.add(flow.flowType);
                        } else {
                            linkMap.set(linkKey, {
                                source: source,
                                target: target,
                                totalBytes: flow.totalBytes || 0,
                                flowCount: flow.flowCount || 1,
                                flows: [flow],
                                protocols: new Set([flow.protocol]),
                                flowTypes: new Set([flow.flowType])
                            });
                        }
                    }
                });

                const links = Array.from(linkMap.values())
                    .sort((a, b) => b.totalBytes - a.totalBytes);
                
                // Calculate node degrees and detect clusters
                const nodeDegrees = new Map();
                const nodeConnections = new Map(); // Track which nodes each node connects to
                
                links.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    
                    nodeDegrees.set(sourceId, (nodeDegrees.get(sourceId) || 0) + 1);
                    nodeDegrees.set(targetId, (nodeDegrees.get(targetId) || 0) + 1);
                    
                    if (!nodeConnections.has(sourceId)) nodeConnections.set(sourceId, new Set());
                    if (!nodeConnections.has(targetId)) nodeConnections.set(targetId, new Set());
                    nodeConnections.get(sourceId).add(targetId);
                    nodeConnections.get(targetId).add(sourceId);
                });
                
                // Simple clustering: group nodes that share many connections
                const clusters = this.detectClusters(nodes, nodeConnections, links);
                
                // Assign cluster positions based on connectivity (most connected in center)
                const clusterPositions = this.calculateClusterPositions(clusters, nodeConnections, width, height);
                
                // Add cluster and degree info to nodes, position them near cluster centers
                nodes.forEach(node => {
                    node.degree = nodeDegrees.get(node.id) || 0;
                    // Find which cluster this node belongs to
                    for (let i = 0; i < clusters.length; i++) {
                        if (clusters[i].includes(node.id)) {
                            node.cluster = i;
                            node.clusterCenter = clusterPositions[i];
                            // Start near cluster center
                            if (node.type === 'device') {
                                node.x = node.clusterCenter.x + (Math.random() - 0.5) * 150;
                                node.y = node.clusterCenter.y + (Math.random() - 0.5) * 150;
                            }
                            break;
                        }
                    }
                    // Default cluster for unassigned nodes
                    if (node.cluster === undefined) {
                        node.cluster = 0;
                        node.clusterCenter = clusterPositions[0];
                        if (node.type === 'device') {
                            node.x = node.clusterCenter.x + (Math.random() - 0.5) * 150;
                            node.y = node.clusterCenter.y + (Math.random() - 0.5) * 150;
                        }
                    }
                });
                
                // Create cluster force that helps with organization and center gravity
                function clusterForce(alpha) {
                    for (let node of nodes) {
                        if (node.clusterCenter && !node.fx && !node.fy) { // Don't apply to dragged nodes
                            const dx = node.clusterCenter.x - node.x;
                            const dy = node.clusterCenter.y - node.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > 0) {
                                // Balanced cluster force for organization without overwhelming
                                const force = alpha * 0.08;
                                node.vx += dx * force;
                                node.vy += dy * force;
                            }
                        }
                    }
                }
                
                // Degree-based radial force - high degree nodes to center, low degree nodes outward
                function degreeRadialForce(alpha) {
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const maxDegree = Math.max(...nodes.map(n => n.degree || 0));
                    
                    for (let node of nodes) {
                        if (!node.fx && !node.fy && node.type === 'device') { // Only apply to unfixed device nodes
                            const dx = centerX - node.x;
                            const dy = centerY - node.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0) {
                                const degree = node.degree || 0;
                                const normalizedDegree = maxDegree > 0 ? degree / maxDegree : 0;
                                
                                // High degree nodes get pulled toward center, low degree nodes get pushed outward
                                const forceDirection = normalizedDegree > 0.3 ? 1 : -1; // Threshold for center vs outward
                                const forceStrength = alpha * 0.05 * (normalizedDegree > 0.3 ? normalizedDegree : (1 - normalizedDegree));
                                
                                node.vx += (dx / distance) * forceDirection * forceStrength;
                                node.vy += (dy / distance) * forceDirection * forceStrength;
                            }
                        }
                    }
                }
                
                // Clustering-based force simulation with much better spacing and center gravity
                this.simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id)
                        .distance(d => {
                            // Shorter, more natural link distances
                            if (d.source.cluster === d.target.cluster) {
                                return 80; // Close intra-cluster links
                            }
                            return 150; // Moderate inter-cluster links
                        })
                        .strength(d => {
                            // Stronger forces for better organization
                            if (d.source.cluster === d.target.cluster) {
                                return 0.7;
                            }
                            return 0.3;
                        }))
                    .force("charge", d3.forceManyBody().strength(d => {
                        // Much stronger repulsion for automatic spreading
                        return d.type === 'device' ? -600 : -300;
                    }))
                    .force("collision", d3.forceCollide()
                        .radius(d => d.type === 'device' ? 110 : 55) // Even larger collision radius
                        .strength(1.0))
                    .force("center", d3.forceCenter(width / 2, height / 2).strength(0.08)) // Stronger center gravity
                    .force("cluster", clusterForce)
                    .force("degreeRadial", degreeRadialForce)
                    .alpha(0.5)
                    .alphaDecay(0.005)
                    .velocityDecay(0.5); // Even more fluid movement
                

                const link = svg.append("g")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("class", "flow-line")
                    .attr("stroke", d => {
                        // Handle mixed protocols
                        if (d.protocols.size > 1) return "#8b5cf6";
                        
                        // Single protocol colors
                        if (d.protocols.has('TCP')) return "#3b82f6";
                        if (d.protocols.has('UDP')) return "#10b981";
                        if (d.protocols.has('ICMP')) return "#f59e0b";
                        if (d.protocols.has('RAW')) return "#8b5cf6";
                        if (d.protocols.has('proto-0')) return "#6b7280";
                        
                        return "#6b7280";
                    })
                    .attr("class", d => {
                        let classes = ["flow-line"];
                        
                        // Add protocol classes
                        if (d.protocols.size > 1) classes.push("mixed");
                        else if (d.protocols.has('TCP')) classes.push("tcp");
                        else if (d.protocols.has('UDP')) classes.push("udp");
                        else if (d.protocols.has('ICMP')) classes.push("icmp");
                        else if (d.protocols.has('RAW')) classes.push("raw");
                        else if (d.protocols.has('proto-0')) classes.push("proto-0");
                        
                        // Add flow type classes
                        if (d.flowTypes.has('subnet')) classes.push("subnet");
                        else if (d.flowTypes.has('virtual')) classes.push("virtual");
                        else if (d.flowTypes.has('physical')) classes.push("physical");
                        
                        return classes.join(" ");
                    })
                    .attr("stroke-dasharray", d => {
                        // Apply dash pattern based on flow type
                        if (d.flowTypes.has('subnet')) return "5,5";
                        if (d.flowTypes.has('virtual')) return "2,2";
                        return "none"; // Physical traffic - solid line
                    })
                    .attr("stroke-width", d => {
                        // Enhanced bandwidth-based thickness scaling
                        const minWidth = 2;
                        const maxWidth = 25;
                        const bytes = d.totalBytes || 1;
                        
                        // Find max bytes in current dataset for relative scaling
                        const maxBytesInView = Math.max(...links.map(l => l.totalBytes || 1));
                        const ratio = bytes / maxBytesInView;
                        
                        // Use cube root for dramatic bandwidth visualization
                        const scaledRatio = Math.pow(ratio, 0.25);
                        return minWidth + (maxWidth - minWidth) * scaledRatio;
                    })
                    .attr("opacity", d => {
                        // More visible opacity based on traffic volume
                        const maxBytesInView = Math.max(...links.map(l => l.totalBytes || 1));
                        const ratio = (d.totalBytes || 1) / maxBytesInView;
                        return Math.min(0.95, 0.4 + 0.5 * ratio);
                    })
                    .on("mouseover", (event, d) => {
                        this.showFlowTooltip(event, d);
                    })
                    .on("mouseout", () => {
                        this.hideTooltip();
                    });
                
                // Create nodes (removed drag to prevent jiggling)
                const node = svg.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node");
                
                // Add metadata boxes for devices
                this.renderDeviceMetadataBoxes(node.filter(d => d.type === 'device'));
                
                // Add clickable external nodes
                this.renderExternalNodes(node.filter(d => d.type === 'external'));
                
                // Create drag behavior with gradual release
                const drag = d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                        // Clear any existing release timer
                        if (d.releaseTimer) {
                            clearTimeout(d.releaseTimer);
                            d.releaseTimer = null;
                        }
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.1);
                        
                        // Gradually release the node after 3 seconds
                        d.releaseTimer = setTimeout(() => {
                            d.fx = null;
                            d.fy = null;
                            // Give simulation a little boost to help it settle
                            this.simulation.alpha(Math.min(0.3, this.simulation.alpha() + 0.1)).restart();
                            d.releaseTimer = null;
                        }, 3000); // 3 second delay before natural movement resumes
                    });

                // Add click, hover, and drag handlers for both devices and external IPs
                node.call(drag)
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        if (d.device) {
                            this.selectDevice(d.device);
                            this.focusOnDevice(d.device);
                        } else if (d.type === 'external') {
                            // Focus on external IP
                            this.focusOnExternalIP(d.id);
                        }
                    })
                    .on("mouseover", (event, d) => {
                        this.showNodeTooltip(event, d);
                    })
                    .on("mouseout", () => {
                        this.hideTooltip();
                    })
                    .on("dblclick", (event, d) => {
                        // Double-click to immediately release from fixed position
                        if (d.releaseTimer) {
                            clearTimeout(d.releaseTimer);
                            d.releaseTimer = null;
                        }
                        d.fx = null;
                        d.fy = null;
                        this.simulation.alpha(0.3).restart();
                    });
                
                // Update positions on simulation tick with stable behavior
                this.simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);
                    
                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                // Allow simulation to naturally settle
                this.simulation.on("end", () => {
                    this.isSimulationStable = true;
                });
            }

            renderCircularLayout() {
                if (!this.networkData) return;
                
                // Stop existing simulation
                if (this.simulation) {
                    this.simulation.stop();
                }
                
                const svg = this.svg.select(".zoom-group");
                svg.selectAll("*").remove();
                
                const width = document.getElementById('networkMap').clientWidth;
                const height = document.getElementById('networkMap').clientHeight;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.3;
                
                // Get devices with flows
                const devicesWithFlows = this.networkData.devices.filter(device => {
                    return this.filteredFlows.some(flow => 
                        flow.sourceDevice?.id === device.id || 
                        flow.destinationDevice?.id === device.id
                    );
                });
                
                const nodes = [];
                const nodeMap = new Map();
                
                // Position devices in a circle
                devicesWithFlows.forEach((device, i) => {
                    const angle = (i / devicesWithFlows.length) * 2 * Math.PI;
                    const node = {
                        id: device.id,
                        name: device.name || device.hostname,
                        type: 'device',
                        device: device,
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle),
                        fx: centerX + radius * Math.cos(angle), // Fixed position
                        fy: centerY + radius * Math.sin(angle)
                    };
                    nodes.push(node);
                    nodeMap.set(device.id, node);
                    
                    device.addresses?.forEach(addr => {
                        const ip = addr.split('/')[0];
                        nodeMap.set(ip, node);
                    });
                });
                
                // Create links
                const links = this.createLinksFromFlows(nodeMap);
                
                // Show ALL links in circular layout
                this.renderNodesAndLinks(svg, nodes, links);
            }

            renderGridLayout() {
                if (!this.networkData) return;
                
                // Stop existing simulation
                if (this.simulation) {
                    this.simulation.stop();
                }
                
                const svg = this.svg.select(".zoom-group");
                svg.selectAll("*").remove();
                
                const width = document.getElementById('networkMap').clientWidth;
                const height = document.getElementById('networkMap').clientHeight;
                
                // Get devices with flows
                const devicesWithFlows = this.networkData.devices.filter(device => {
                    return this.filteredFlows.some(flow => 
                        flow.sourceDevice?.id === device.id || 
                        flow.destinationDevice?.id === device.id
                    );
                });
                
                const nodes = [];
                const nodeMap = new Map();
                
                // Calculate grid dimensions
                const cols = Math.ceil(Math.sqrt(devicesWithFlows.length));
                const rows = Math.ceil(devicesWithFlows.length / cols);
                const cellWidth = (width * 0.8) / cols;
                const cellHeight = (height * 0.8) / rows;
                const startX = width * 0.1;
                const startY = height * 0.1;
                
                // Position devices in a grid
                devicesWithFlows.forEach((device, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const node = {
                        id: device.id,
                        name: device.name || device.hostname,
                        type: 'device',
                        device: device,
                        x: startX + col * cellWidth + cellWidth / 2,
                        y: startY + row * cellHeight + cellHeight / 2,
                        fx: startX + col * cellWidth + cellWidth / 2, // Fixed position
                        fy: startY + row * cellHeight + cellHeight / 2
                    };
                    nodes.push(node);
                    nodeMap.set(device.id, node);
                    
                    device.addresses?.forEach(addr => {
                        const ip = addr.split('/')[0];
                        nodeMap.set(ip, node);
                    });
                });
                
                // Create links
                const links = this.createLinksFromFlows(nodeMap);
                
                // Show ALL links in grid layout
                this.renderNodesAndLinks(svg, nodes, links);
            }

            showFlowTooltip(event, linkData) {
                const tooltip = this.getOrCreateTooltip();
                
                // Calculate traffic percentage relative to max
                const maxBytesInView = Math.max(...(this.filteredFlows.map(f => f.totalBytes || 1)));
                const trafficPercent = ((linkData.totalBytes / maxBytesInView) * 100).toFixed(1);
                
                // Check if IPv6 is involved
                const hasIPv6 = linkData.flows.some(flow => 
                    this.isIPv6(flow.sourceIP) || this.isIPv6(flow.destinationIP)
                );
                
                tooltip.innerHTML = `
                    <div class="font-semibold">Connection Summary</div>
                    <div>From: ${linkData.source.name || linkData.source.id}</div>
                    <div>To: ${linkData.target.name || linkData.target.id}</div>
                    <div>Traffic: ${this.formatBytes(linkData.totalBytes)} (${trafficPercent}%)</div>
                    <div>Aggregated Flows: ${linkData.flowCount}</div>
                    <div>Protocols: ${Array.from(linkData.protocols).join(', ')}</div>
                    <div>Flow Types: ${Array.from(linkData.flowTypes || new Set()).join(', ')}</div>
                    ${hasIPv6 ? '<div>ðŸŒ Contains IPv6 traffic</div>' : '<div>ðŸ“ IPv4 only</div>'}
                `;
                
                this.positionTooltip(tooltip, event);
            }

            showNodeTooltip(event, nodeData) {
                const tooltip = this.getOrCreateTooltip();
                
                if (nodeData.type === 'device' && nodeData.device) {
                    const device = nodeData.device;
                    
                    // Calculate flows and traffic for this device
                    const deviceFlows = this.filteredFlows.filter(flow => 
                        flow.sourceDevice?.id === device.id || flow.destinationDevice?.id === device.id
                    );
                    const totalTraffic = deviceFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                    
                    // Count connections (degree)
                    const connections = nodeData.degree || 0;
                    
                    // Determine device role
                    let role = 'Machine';
                    if (device.tags?.includes('exit-node')) role = 'Exit Node';
                    else if (device.tags?.includes('subnet-router')) role = 'Subnet Router';
                    else if (device.tags?.includes('ssh')) role = 'SSH Server';
                    
                    const isOnline = this.isDeviceOnline(device);
                    
                    tooltip.innerHTML = `
                        <div class="font-semibold">${device.name || device.hostname || 'Unknown'}</div>
                        <div>Role: ${role}</div>
                        <div>Status: ${isOnline ? 'ðŸŸ¢ Online' : 'ðŸ”´ Offline'}</div>
                        <div>OS: ${device.os || 'Unknown'}</div>
                        <div>User: ${device.user || 'N/A'}</div>
                        <div>Connections: ${connections}</div>
                        <div>Traffic: ${this.formatBytes(totalTraffic)}</div>
                        <div>Flows: ${deviceFlows.length}</div>
                        <div>IPs: ${device.addresses?.length || 0}</div>
                        ${device.tags?.length ? `<div>Tags: ${device.tags.join(', ')}</div>` : ''}
                    `;
                } else if (nodeData.type === 'external') {
                    // External IP node
                    const externalFlows = this.filteredFlows.filter(flow => 
                        flow.sourceIP === nodeData.id || flow.destinationIP === nodeData.id
                    );
                    const totalTraffic = externalFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                    const connections = nodeData.degree || 0;
                    
                    tooltip.innerHTML = `
                        <div class="font-semibold">External IP</div>
                        <div>Address: ${nodeData.id}</div>
                        <div>Type: ${this.isIPv6(nodeData.id) ? 'IPv6' : 'IPv4'}</div>
                        <div>Connections: ${connections}</div>
                        <div>Traffic: ${this.formatBytes(totalTraffic)}</div>
                        <div>Flows: ${externalFlows.length}</div>
                    `;
                }
                
                this.positionTooltip(tooltip, event);
            }



            getOrCreateTooltip() {
                let tooltip = document.getElementById('flow-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'flow-tooltip';
                    tooltip.className = 'absolute bg-black text-white text-xs rounded p-2 pointer-events-none z-50 hidden';
                    document.body.appendChild(tooltip);
                }
                tooltip.classList.remove('hidden');
                return tooltip;
            }

            positionTooltip(tooltip, event) {
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            }

            hideTooltip() {
                const tooltip = document.getElementById('flow-tooltip');
                if (tooltip) {
                    tooltip.classList.add('hidden');
                }
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            dragstarted(event, d) {
                // Don't restart simulation to prevent jiggling
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            dragended(event, d) {
                // Allow nodes to settle in new position without restarting simulation
                d.fx = null;
                d.fy = null;
            }

            toggleSidebar(show) {
                const sidebar = document.getElementById('sidebar');
                const expandBtn = document.getElementById('expandSidebar');
                
                if (show) {
                    sidebar.classList.remove('collapsed');
                    expandBtn.classList.add('hidden');
                } else {
                    sidebar.classList.add('collapsed');
                    expandBtn.classList.remove('hidden');
                }
            }

            updateStats() {
                // Count only machines with flows
                const machinesWithFlows = this.networkData?.devices?.filter(device => {
                    return this.networkData.flows.some(flow => 
                        flow.sourceDevice?.id === device.id || 
                        flow.destinationDevice?.id === device.id ||
                        device.addresses?.some(addr => {
                            const ip = addr.split('/')[0];
                            return flow.sourceIP === ip || flow.destinationIP === ip;
                        })
                    );
                }).length || 0;
                
                const flowCount = this.filteredFlows?.length || 0;
                const totalFlows = this.networkData?.flows?.length || 0;
                
                // Calculate tailnet throughput
                const timeRange = this.networkData?.timeRange;
                let throughput = 0;
                if (timeRange && this.filteredFlows?.length > 0) {
                    const totalBytes = this.filteredFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                    const durationSeconds = (new Date(timeRange.end) - new Date(timeRange.start)) / 1000;
                    if (durationSeconds > 0) {
                        throughput = totalBytes / durationSeconds;
                    }
                }
                
                document.getElementById('deviceCount').textContent = `${machinesWithFlows} active machine${machinesWithFlows !== 1 ? 's' : ''}`;
                document.getElementById('tailnetThroughput').textContent = this.formatBytes(throughput) + '/s';
                
                if (flowCount < totalFlows) {
                    document.getElementById('flowCount').textContent = `${flowCount}/${totalFlows} flows`;
                } else {
                    document.getElementById('flowCount').textContent = `${flowCount} flow${flowCount !== 1 ? 's' : ''}`;
                }
            }

            setTimeRange(range) {
                const end = new Date();
                let start;
                
                switch(range) {
                    case '15min':
                        start = new Date(end.getTime() - 15 * 60 * 1000);
                        break;
                    case '1h':
                        start = new Date(end.getTime() - 60 * 60 * 1000);
                        break;
                    case '3h':
                        start = new Date(end.getTime() - 3 * 60 * 60 * 1000);
                        break;
                    case '6h':
                        start = new Date(end.getTime() - 6 * 60 * 60 * 1000);
                        break;
                }
                
                document.getElementById('startTime').value = this.formatDateTimeLocal(start);
                document.getElementById('endTime').value = this.formatDateTimeLocal(end);
            }

            formatDateTimeLocal(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            }

            renderDeviceMetadataBoxes(deviceNodes) {
                deviceNodes.each(function(d) {
                    const nodeGroup = d3.select(this);
                    
                    // Calculate device traffic
                    const deviceFlows = window.tsflowApp.filteredFlows.filter(flow => 
                        flow.sourceDevice?.id === d.device.id || flow.destinationDevice?.id === d.device.id
                    );
                    const totalTraffic = deviceFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                    
                    // Box dimensions - balanced for readability
                    const boxWidth = 130;
                    const boxHeight = 65;
                    
                    // Simple online status determination
                    const deviceOnline = window.tsflowApp.isDeviceOnline(d.device);
                    
                    // Main background box with consistent online status
                    nodeGroup.append("rect")
                        .attr("x", -boxWidth/2)
                        .attr("y", -boxHeight/2)
                        .attr("width", boxWidth)
                        .attr("height", boxHeight)
                        .attr("rx", 8)
                        .attr("fill", deviceOnline ? "#1e293b" : "#0f172a")
                        .attr("stroke", () => {
                            if (window.tsflowApp.selectedDevice && d.device?.id === window.tsflowApp.selectedDevice.id) {
                                return "#f59e0b";
                            }
                            if (window.tsflowApp.focusedDevice && d.device?.id === window.tsflowApp.focusedDevice.id) {
                                return "#f97316";
                            }
                            return deviceOnline ? "#10b981" : "#64748b";
                        })
                        .attr("stroke-width", () => {
                            if (window.tsflowApp.selectedDevice && d.device?.id === window.tsflowApp.selectedDevice.id) {
                                return 3;
                            }
                            if (window.tsflowApp.focusedDevice && d.device?.id === window.tsflowApp.focusedDevice.id) {
                                return 3;
                            }
                            return 2;
                        });
                    
                    // Status indicator
                    nodeGroup.append("circle")
                        .attr("cx", boxWidth/2 - 8)
                        .attr("cy", -boxHeight/2 + 8)
                        .attr("r", 4)
                        .attr("fill", deviceOnline ? "#10b981" : "#64748b");
                    
                    // Device name (truncated)
                    const deviceName = d.device.name || d.device.hostname || 'Unknown';
                    nodeGroup.append("text")
                        .text(deviceName.length > 14 ? deviceName.substring(0, 11) + '...' : deviceName)
                        .attr("x", 0)
                        .attr("y", -15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("font-weight", "600")
                        .attr("fill", "#f8fafc");
                    
                    // OS and IP info
                    const osText = d.device.os || 'Unknown';
                    const ipCount = d.device.addresses?.length || 0;
                    nodeGroup.append("text")
                        .text(`${osText} â€¢ ${ipCount} IP${ipCount !== 1 ? 's' : ''}`)
                        .attr("x", 0)
                        .attr("y", -2)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("fill", "#94a3b8");
                    
                    // Traffic info
                    if (totalTraffic > 0) {
                        nodeGroup.append("text")
                            .text(window.tsflowApp.formatBytes(totalTraffic))
                            .attr("x", 0)
                            .attr("y", 12)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "9px")
                            .attr("font-weight", "500")
                            .attr("fill", "#10b981");
                    }
                    
                    // Tags (if any)
                    if (d.device.tags && d.device.tags.length > 0) {
                        const tagText = d.device.tags.join(', ');
                        nodeGroup.append("text")
                            .text(tagText.length > 20 ? tagText.substring(0, 17) + '...' : tagText)
                            .attr("x", 0)
                            .attr("y", 25)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px")
                            .attr("fill", "#3b82f6");
                    }
                });
            }

            renderExternalNodes(externalNodes) {
                externalNodes.each(function(d) {
                    const nodeGroup = d3.select(this);
                    
                    // Calculate traffic for this external IP
                    const externalFlows = window.tsflowApp.filteredFlows.filter(flow => 
                        flow.sourceIP === d.id || flow.destinationIP === d.id
                    );
                    const totalTraffic = externalFlows.reduce((sum, flow) => sum + (flow.totalBytes || 0), 0);
                    
                    // External IP box - adjust height if we have traffic to show
                    const boxWidth = 90;
                    const boxHeight = totalTraffic > 0 ? 40 : 35;
                    
                    // Check if this external IP is focused
                    const isFocused = window.tsflowApp.focusedExternalIP === d.id;
                    
                    nodeGroup.append("rect")
                        .attr("x", -boxWidth/2)
                        .attr("y", -boxHeight/2)
                        .attr("width", boxWidth)
                        .attr("height", boxHeight)
                        .attr("rx", 4)
                        .attr("class", "external-ip-card")
                        .attr("fill", isFocused ? "#9a3412" : "#7c2d12")
                        .attr("stroke", isFocused ? "#f97316" : "#ea580c")
                        .attr("stroke-width", isFocused ? 3 : 1.5);
                    
                    // External IP label (truncated)
                    const ipText = d.name.length > 14 ? d.name.substring(0, 11) + '...' : d.name;
                    const yPosition = totalTraffic > 0 ? -4 : (isFocused ? 0 : 4);
                    nodeGroup.append("text")
                        .text(ipText)
                        .attr("x", 0)
                        .attr("y", yPosition)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "9px")
                        .attr("font-weight", isFocused ? "600" : "500")
                        .attr("fill", "#fed7aa");
                    
                    // Traffic info
                    if (totalTraffic > 0) {
                        nodeGroup.append("text")
                            .text(window.tsflowApp.formatBytes(totalTraffic))
                            .attr("x", 0)
                            .attr("y", 10)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px")
                            .attr("font-weight", "500")
                            .attr("fill", "#fbbf24");
                    }
                    
                    // Add focus indicator
                    if (isFocused) {
                        nodeGroup.append("text")
                            .text("ðŸŽ¯")
                            .attr("x", boxWidth/2 - 8)
                            .attr("y", -boxHeight/2 + 10)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "8px");
                    }
                });
            }

            exportTailnetData() {
                if (!this.networkData) return;
                
                const data = {
                    exportTime: new Date().toISOString(),
                    tailnet: {
                        timeRange: this.networkData.timeRange,
                        machines: this.networkData.devices,
                        flows: this.filteredFlows,
                        exportedBy: 'TSFlow Tailnet Visualizer'
                    }
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tailnet-flow-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Flow Log Viewer Methods
            toggleFlowViewer() {
                const viewer = document.getElementById('flowLogViewer');
                const toggleBtn = document.getElementById('toggleFlowViewer');
                const icon = toggleBtn.querySelector('i');
                
                if (this.flowLogCollapsed) {
                    viewer.style.height = '300px';
                    icon.className = 'fas fa-chevron-down text-xs';
                    this.flowLogCollapsed = false;
                } else {
                    viewer.style.height = '125px'; // Header + filter row + pagination row height
                    icon.className = 'fas fa-chevron-up text-xs';
                    this.flowLogCollapsed = true;
                }
            }



            exportFlowLogs() {
                if (this.flowLogEntries.length === 0) return;
                
                const csvHeaders = ['Time', 'Source', 'Destination', 'Protocol', 'Ports', 'Bytes', 'Type'];
                const csvRows = this.flowLogEntries.map(entry => [
                    entry.timestamp,
                    entry.source,
                    entry.destination,
                    entry.protocol,
                    entry.ports || '',
                    entry.bytes,
                    entry.flowType
                ].map(field => `"${field}"`).join(','));
                
                const csvContent = [csvHeaders.join(','), ...csvRows].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tsflow-logs-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            updateFlowLogs() {
                if (!this.rawFlows || this.rawFlows.length === 0) return;
                
                // Apply independent flow log filters to raw flows
                let filtered = this.rawFlows.filter(rawFlow => {
                    // Protocol filter (independent from map filter)
                    if (this.flowLogFilters.protocol) {
                        if (this.flowLogFilters.protocol === 'proto-0') {
                            if (rawFlow.protocol !== 'proto-0' && rawFlow.protocol !== '0') return false;
                        } else if (rawFlow.protocol !== this.flowLogFilters.protocol) {
                            return false;
                        }
                    }
                    
                    // Port filter (independent from map filter)
                    if (this.flowLogFilters.port) {
                        const searchPort = this.flowLogFilters.port.trim();
                        if (searchPort) {
                            const hasPort = rawFlow.sourcePort === searchPort || rawFlow.destinationPort === searchPort;
                            if (!hasPort) return false;
                        }
                    }
                    
                    // Minimum bytes filter
                    if (this.flowLogFilters.minBytes > 0) {
                        if ((rawFlow.totalBytes || 0) < this.flowLogFilters.minBytes) return false;
                    }
                    
                    // External IPs filter (independent from map filter)
                    if (!this.flowLogFilters.showExternal) {
                        if (!rawFlow.sourceDevice || !rawFlow.destinationDevice) return false;
                    }
                    
                    // IPv4/IPv6 filter (independent from map filter)
                    const hasIPv4 = !this.isIPv6(rawFlow.sourceIP) || !this.isIPv6(rawFlow.destinationIP);
                    const hasIPv6 = this.isIPv6(rawFlow.sourceIP) || this.isIPv6(rawFlow.destinationIP);
                    
                    if (!this.flowLogFilters.showIPv4 && hasIPv4 && !hasIPv6) return false;
                    if (!this.flowLogFilters.showIPv6 && hasIPv6 && !hasIPv4) return false;
                    
                    // Focus device filter (sync with graph focus)
                    if (this.focusedDevice) {
                        const isConnected = (rawFlow.sourceDevice?.id === this.focusedDevice.id) ||
                                          (rawFlow.destinationDevice?.id === this.focusedDevice.id) ||
                                          (rawFlow.sourceIP === this.getDeviceMainIP(this.focusedDevice)) ||
                                          (rawFlow.destinationIP === this.getDeviceMainIP(this.focusedDevice));
                        if (!isConnected) return false;
                    }
                    
                    // Focus external IP filter (sync with graph focus)
                    if (this.focusedExternalIP) {
                        const isConnected = (rawFlow.sourceIP === this.focusedExternalIP) ||
                                          (rawFlow.destinationIP === this.focusedExternalIP);
                        if (!isConnected) return false;
                    }
                    
                    // Search query filter (independent from map filter)
                    if (this.flowLogFilters.searchQuery) {
                        return this.matchesRawFlowSearchQuery(rawFlow, this.flowLogFilters.searchQuery);
                    }
                    
                    return true;
                });
                
                // Sort by most recent first
                filtered.sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                // Convert all filtered flows to log entries (don't limit here)
                const newEntries = filtered.map(rawFlow => {
                    const sourceDevice = rawFlow.sourceDevice?.name || rawFlow.sourceDevice?.hostname || rawFlow.sourceIP;
                    const destDevice = rawFlow.destinationDevice?.name || rawFlow.destinationDevice?.hostname || rawFlow.destinationIP;
                    
                    // Format ports display
                    let portsDisplay = '';
                    if (rawFlow.sourcePort && rawFlow.destinationPort) {
                        portsDisplay = `${rawFlow.sourcePort} â†’ ${rawFlow.destinationPort}`;
                    } else if (rawFlow.destinationPort) {
                        portsDisplay = `* â†’ ${rawFlow.destinationPort}`;
                    } else if (rawFlow.sourcePort) {
                        portsDisplay = `${rawFlow.sourcePort} â†’ *`;
                    } else {
                        portsDisplay = '';
                    }
                    
                    return {
                        timestamp: rawFlow.timestamp,
                        source: sourceDevice,
                        destination: destDevice,
                        protocol: rawFlow.protocol,
                        ports: portsDisplay,
                        bytes: rawFlow.totalBytes || 0,
                        flowType: rawFlow.flowType || 'unknown',
                        flow: rawFlow, // Keep reference for click handling
                        direction: rawFlow.direction || 'bidirectional'
                    };
                });
                
                this.flowLogEntries = newEntries;
                
                // Update pagination info
                this.flowLogPagination.totalEntries = newEntries.length;
                this.flowLogPagination.totalPages = Math.max(1, Math.ceil(newEntries.length / this.flowLogPagination.pageSize));
                
                // Ensure current page is valid
                if (this.flowLogPagination.currentPage > this.flowLogPagination.totalPages) {
                    this.flowLogPagination.currentPage = this.flowLogPagination.totalPages;
                }
                if (this.flowLogPagination.currentPage < 1) {
                    this.flowLogPagination.currentPage = 1;
                }
                
                this.updateFlowLogDisplay();
            }

            matchesRawFlowSearchQuery(rawFlow, query) {
                const lowerQuery = query.toLowerCase();
                
                // Handle special search syntax
                if (lowerQuery.includes(':')) {
                    const parts = lowerQuery.split(' ').filter(p => p.includes(':'));
                    for (const part of parts) {
                        const [key, value] = part.split(':');
                        
                        switch (key) {
                            case 'protocol':
                                if (rawFlow.protocol.toLowerCase() !== value) return false;
                                break;
                            case 'port':
                                if (rawFlow.sourcePort !== value && rawFlow.destinationPort !== value) return false;
                                break;
                            case 'ip':
                                if (rawFlow.sourceIP !== value && rawFlow.destinationIP !== value) return false;
                                break;
                            case 'direction':
                                if (rawFlow.direction?.toLowerCase() !== value) return false;
                                break;
                        }
                    }
                    
                    // Remove special syntax for general search
                    const generalQuery = lowerQuery.replace(/\w+:[^\s]+/g, '').trim();
                    if (!generalQuery) return true;
                    query = generalQuery;
                }
                
                // General text search
                const searchText = [
                    rawFlow.sourceIP,
                    rawFlow.destinationIP,
                    rawFlow.sourceDevice?.name,
                    rawFlow.sourceDevice?.hostname,
                    rawFlow.destinationDevice?.name,
                    rawFlow.destinationDevice?.hostname,
                    rawFlow.protocol,
                    rawFlow.sourcePort,
                    rawFlow.destinationPort,
                    rawFlow.direction
                ].filter(Boolean).join(' ').toLowerCase();
                
                return searchText.includes(query.toLowerCase());
            }



            updateFlowLogDisplay() {
                const tbody = document.getElementById('flowLogBody');
                const countElement = document.getElementById('flowLogCount');
                const rateElement = document.getElementById('flowLogRate');
                
                // Update count
                countElement.textContent = `${this.flowLogEntries.length} flows`;
                
                // Update focus indicator
                const focusIndicator = document.getElementById('flowLogFocusIndicator');
                if (this.focusedDevice) {
                    focusIndicator.textContent = `ðŸŽ¯ ${this.focusedDevice.name || this.focusedDevice.hostname}`;
                    focusIndicator.classList.remove('hidden');
                } else if (this.focusedExternalIP) {
                    focusIndicator.textContent = `ðŸŽ¯ ${this.focusedExternalIP}`;
                    focusIndicator.classList.remove('hidden');
                } else {
                    focusIndicator.classList.add('hidden');
                }
                
                // Calculate rate based on time range
                if (this.networkData?.timeRange) {
                    const start = new Date(this.networkData.timeRange.start);
                    const end = new Date(this.networkData.timeRange.end);
                    const durationSeconds = (end - start) / 1000;
                    const rate = durationSeconds > 0 ? Math.round(this.flowLogEntries.length / durationSeconds) : 0;
                    rateElement.textContent = `${rate}/s avg`;
                } else {
                    rateElement.textContent = '0/s';
                }
                
                // Calculate pagination
                const startIndex = (this.flowLogPagination.currentPage - 1) * this.flowLogPagination.pageSize;
                const endIndex = startIndex + this.flowLogPagination.pageSize;
                const currentPageEntries = this.flowLogEntries.slice(startIndex, endIndex);
                
                // Update pagination controls
                this.updatePaginationControls();
                
                // Update table with current page entries
                tbody.innerHTML = '';
                currentPageEntries.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    row.className = 'hover:bg-slate-700 cursor-pointer';
                    
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const bytes = this.formatBytes(entry.bytes);
                    
                    // Add protocol styling
                    let protocolClass = 'text-purple-400'; // default
                    if (entry.protocol === 'TCP') protocolClass = 'text-blue-400';
                    else if (entry.protocol === 'UDP') protocolClass = 'text-green-400';
                    else if (entry.protocol === 'ICMP') protocolClass = 'text-orange-400';
                    else if (entry.protocol === 'RAW') protocolClass = 'text-purple-400';
                    else if (entry.protocol === 'proto-0') protocolClass = 'text-gray-400';

                    // Direction indicator
                    let directionIcon = 'â†”ï¸';
                    if (entry.direction === 'outbound') directionIcon = 'â†’';
                    else if (entry.direction === 'inbound') directionIcon = 'â†';
                    
                    row.innerHTML = `
                        <td class="p-2 text-slate-300">${time}</td>
                        <td class="p-2 text-slate-200 truncate max-w-32" title="${entry.source}">${entry.source}</td>
                        <td class="p-2 text-slate-200 truncate max-w-32" title="${entry.destination}">${directionIcon} ${entry.destination}</td>
                        <td class="p-2 ${protocolClass} font-medium">${entry.protocol}</td>
                        <td class="p-2 text-slate-300 font-mono text-sm">${entry.ports}</td>
                        <td class="p-2 text-yellow-400">${bytes}</td>
                        <td class="p-2 text-slate-400">${entry.flowType}</td>
                    `;
                    
                    // Add click handler to highlight corresponding flow in visualization
                    row.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Clear previous selection styling from all rows across all pages
                        document.querySelectorAll('#flowLogBody tr').forEach(r => {
                            r.classList.remove('bg-blue-900', 'border-blue-500');
                            r.style.borderLeft = '';
                        });
                        
                        // Add selection styling to clicked row
                        row.classList.add('bg-blue-900', 'border-blue-500');
                        row.style.borderLeft = '3px solid #3b82f6';
                        
                        // Highlight the flow on the graph
                        if (entry.flow) {
                            this.highlightFlow(entry.flow, row);
                            document.getElementById('clearFlowSelection').classList.remove('hidden');
                        }
                    });
                    
                    tbody.appendChild(row);
                });
            }

            highlightFlow(flow, selectedRow = null) {
                if (!this.svg) return;
                
                // Store reference to selected row for clearing later
                this.selectedFlowRow = selectedRow;
                
                // Clear any existing highlights
                this.clearFlowHighlight(false);
                
                let highlightFound = false;
                

                
                // Find the corresponding link in the visualization
                const links = this.svg.selectAll('.flow-line');
                
                links.each(function(d) {
                    // First, try to match against the link endpoints directly
                    // since links represent connections between specific nodes
                    let linkMatches = false;
                    
                    // Check if this link connects the same IPs as our flow
                    const sourceNodeMatches = flow.sourceIP && (
                        d.source.id === flow.sourceIP || 
                        (d.source.device && flow.sourceDevice && d.source.device.id === flow.sourceDevice.id)
                    );
                    
                    const targetNodeMatches = flow.destinationIP && (
                        d.target.id === flow.destinationIP || 
                        (d.target.device && flow.destinationDevice && d.target.device.id === flow.destinationDevice.id)
                    );
                    
                    // Check both directions (source->target and target->source)
                    const direction1 = sourceNodeMatches && targetNodeMatches;
                    
                    const reverseSourceMatches = flow.destinationIP && (
                        d.source.id === flow.destinationIP || 
                        (d.source.device && flow.destinationDevice && d.source.device.id === flow.destinationDevice.id)
                    );
                    
                    const reverseTargetMatches = flow.sourceIP && (
                        d.target.id === flow.sourceIP || 
                        (d.target.device && flow.sourceDevice && d.target.device.id === flow.sourceDevice.id)
                    );
                    
                    const direction2 = reverseSourceMatches && reverseTargetMatches;
                    
                    // Check if the protocol also matches any of the aggregated flows
                    const protocolMatches = d.flows && d.flows.some(linkFlow => 
                        linkFlow.protocol === flow.protocol
                    );
                    
                    linkMatches = (direction1 || direction2) && protocolMatches;
                    
                    if (linkMatches) {
                        highlightFound = true;
                        
                        // Highlight the link with bright color and thicker line
                        d3.select(this)
                            .style('stroke-width', '12px')
                            .style('opacity', '1')
                            .style('stroke', '#f59e0b') // Orange highlight
                            .classed('highlighted-flow', true);
                        
                        // Highlight connected nodes
                        const sourceNode = d.source;
                        const targetNode = d.target;
                        
                        window.tsflowApp.svg.selectAll('.node').each(function(nodeData) {
                            if (nodeData.id === sourceNode.id || nodeData.id === targetNode.id) {
                                d3.select(this).select('rect')
                                    .style('stroke', '#f59e0b')
                                    .style('stroke-width', '4px')
                                    .classed('highlighted-node', true);
                            }
                        });
                    }
                });
                
                // If no match found by link endpoints, try to match by IPs in the aggregated flows
                if (!highlightFound) {
                    links.each(function(d) {
                        const ipMatch = d.flows && d.flows.some(linkFlow => {
                            // Must match protocol
                            if (linkFlow.protocol !== flow.protocol) return false;
                            
                            // Match IPs (both directions)
                            const ipMatch1 = (linkFlow.sourceIP === flow.sourceIP && 
                                            linkFlow.destinationIP === flow.destinationIP);
                            const ipMatch2 = (linkFlow.sourceIP === flow.destinationIP && 
                                            linkFlow.destinationIP === flow.sourceIP);
                            
                            return ipMatch1 || ipMatch2;
                        });
                        
                        if (ipMatch) {
                            highlightFound = true;
                            
                            // Highlight with slightly different style
                            d3.select(this)
                                .style('stroke-width', '8px')
                                .style('opacity', '0.8')
                                .style('stroke', '#8b5cf6') // Purple highlight for IP match
                                .classed('highlighted-flow', true);
                        }
                    });
                }
                
                // If still no match, try device-only matching (most permissive)
                if (!highlightFound && (flow.sourceDevice || flow.destinationDevice)) {
                    links.each(function(d) {
                        // Check if this link connects devices involved in the flow
                        const hasSourceDevice = flow.sourceDevice && 
                            (d.source.device?.id === flow.sourceDevice.id || d.target.device?.id === flow.sourceDevice.id);
                        const hasDestDevice = flow.destinationDevice && 
                            (d.source.device?.id === flow.destinationDevice.id || d.target.device?.id === flow.destinationDevice.id);
                            
                        if (hasSourceDevice || hasDestDevice) {
                            highlightFound = true;
                            
                            // Highlight with subtle style for device match
                            d3.select(this)
                                .style('stroke-width', '6px')
                                .style('opacity', '0.6')
                                .style('stroke', '#06b6d4') // Cyan highlight for device match
                                .classed('highlighted-flow', true);
                        }
                    });
                }
                
                // Show notification if no match found
                if (!highlightFound) {
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-20 right-4 bg-red-600 text-white px-4 py-2 rounded shadow-lg z-50';
                    notification.innerHTML = `
                        <div class="font-semibold">Flow Not Visible</div>
                        <div class="text-sm">This flow may be filtered out or aggregated.</div>
                    `;
                    document.body.appendChild(notification);
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 3000);
                }
            }

            clearFlowHighlight(clearRowSelection = true) {
                if (!this.svg) return;
                
                // Clear link highlights
                this.svg.selectAll('.flow-line.highlighted-flow')
                    .style('stroke-width', null)
                    .style('opacity', null)
                    .style('stroke', null)
                    .classed('highlighted-flow', false);
                
                // Clear node highlights
                this.svg.selectAll('.node.highlighted-node rect, .node rect.highlighted-node')
                    .style('stroke-width', null)
                    .style('stroke', null)
                    .classed('highlighted-node', false);
                
                // Clear row selection if requested
                if (clearRowSelection && this.selectedFlowRow) {
                    this.selectedFlowRow.classList.remove('bg-blue-900', 'border-blue-500');
                    this.selectedFlowRow.style.borderLeft = '';
                    this.selectedFlowRow = null;
                }
                
                // Hide clear button
                document.getElementById('clearFlowSelection').classList.add('hidden');
            }

            clearFlowLogFilters() {
                document.getElementById('flowLogSearch').value = '';
                document.getElementById('flowLogProtocol').value = '';
                document.getElementById('flowLogPort').value = '';
                document.getElementById('flowLogMinBytes').value = '';
                document.getElementById('flowLogShowExternal').checked = true;
                document.getElementById('flowLogShowIPv4').checked = true;
                document.getElementById('flowLogShowIPv6').checked = true;
                
                this.flowLogFilters = {
                    protocol: '',
                    port: '',
                    searchQuery: '',
                    showExternal: true,
                    showIPv4: true,
                    showIPv6: true,
                    minBytes: 0
                };
                
                // Reset pagination
                this.flowLogPagination.currentPage = 1;
                
                this.updateFlowLogs();
            }

            updatePaginationControls() {
                const firstBtn = document.getElementById('flowLogFirstPage');
                const prevBtn = document.getElementById('flowLogPrevPage');
                const nextBtn = document.getElementById('flowLogNextPage');
                const lastBtn = document.getElementById('flowLogLastPage');
                const pageInfo = document.getElementById('flowLogPageInfo');
                
                const currentPage = this.flowLogPagination.currentPage;
                const totalPages = this.flowLogPagination.totalPages;
                
                // Update page info
                pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                
                // Update button states
                firstBtn.disabled = currentPage === 1;
                prevBtn.disabled = currentPage === 1;
                nextBtn.disabled = currentPage === totalPages || totalPages === 0;
                lastBtn.disabled = currentPage === totalPages || totalPages === 0;
                
                // Update count display
                const countElement = document.getElementById('flowLogCount');
                countElement.textContent = `${this.flowLogPagination.totalEntries} flows`;
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.tsflowApp = new TSFlowApp();
        });
    </script>
</body>
</html> 